<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HP Artwork Generator (72 DPI, HQ)</title>
  <style>
    :root { --gap: 16px; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; }
    .wrap { display: grid; grid-template-columns: 360px 1fr; gap: var(--gap); padding: var(--gap); align-items: start; }
    .panel {
      border: 1px solid #e6e6e6; border-radius: 12px; padding: 14px; position: sticky; top: 12px;
      background: #fff;
    }
    .field { margin-bottom: 12px; }
    label { display: block; font-size: 12px; opacity: 0.85; margin-bottom: 6px; }
    input[type="text"], select, button {
      font-size: 14px; padding: 9px 10px; width: 100%;
      border: 1px solid #d9d9d9; border-radius: 10px; background: #fff;
      box-sizing: border-box;
    }
    input[type="checkbox"] { transform: scale(1.1); }
    button { cursor: pointer; }
    .btnRow { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; }
    .meta { font-size: 12px; opacity: 0.8; line-height: 1.35; margin-top: 8px; }
    .stage {
      border: 1px solid #e6e6e6; border-radius: 12px; padding: 14px; background: #fff;
      overflow: auto;
    }
    canvas { border: 1px solid #cfcfcf; display: block; max-width: 100%; height: auto; touch-action: none; }
    .hint { font-size: 12px; opacity: 0.75; margin-bottom: 10px; }
    .row2 { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .toggleLine { display: flex; gap: 10px; align-items: center; padding: 8px 10px; border: 1px solid #d9d9d9; border-radius: 10px; }
    .toggleLine span { font-size: 14px; }
  </style>
</head>
<body>
  <div class="wrap">
    <!-- LEFT COLUMN -->
    <div class="panel">
      <div class="field">
        <label>Upload image (any size)</label>
        <input id="fileInput" type="file" accept="image/*" />
        <div class="meta" id="imgInfo">No image loaded.</div>
      </div>

      <div class="field">
        <label>Tile size (inches) @ 72 DPI(Default for Adobe Illustrator)</label>
        <input id="imgIn" type="text" value='1"' />
      </div>

      <div class="field">
        <label>Gap around each cell (inches)</label>
        <input id="gapIn" type="text" value='0"' />
      </div>

      <div class="row2">
        <div class="field">
          <label>Final width (inches)</label>
          <input id="outWIn" type="text" value='8.5"' />
        </div>
        <div class="field">
          <label>Final height (inches)</label>
          <input id="outHIn" type="text" value='11"' />
        </div>
      </div>

      <div class="field">
        <label>Hex-packed circle overlay</label>
        <div class="toggleLine">
          <input id="hexToggle" type="checkbox" />
          <span>Show hex-packed circles</span>
        </div>
        <div style="height:10px;"></div>
        <label>Circle diameter (inches)</label>
        <input id="circleDiaIn" type="text" value='6.25"' />
      </div>

      <div class="field">
        <label>Export format</label>
        <select id="format">
          <option value="png">PNG</option>
          <option value="jpg">JPG</option>
          <option value="pdf">PDF</option>
        </select>
      </div>

      <div class="btnRow">
        <button id="renderBtn">Reload Canvas</button>
        <button id="exportBtn">Export</button>
      </div>

      <div class="meta" id="renderInfo">
        Tip: Edit inputs freely, then click <b>Reload Canvas</b> to redraw.
      </div>
    </div>

    <!-- RIGHT COLUMN -->
    <div class="stage">
      <div class="hint">
        Preview is a <b>6.25&quot;×6.25&quot; window</b> into the full output. Drag to pan. Pinch/scroll to zoom.
        <br/>If output is too large for in-browser PNG/JPG, the app auto-switches to <b>tiled PDF</b> and disables PNG/JPG.
      </div>
      <canvas id="canvas"></canvas>
    </div>
  </div>

  <!-- jsPDF for PDF export -->
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <script>
    // ---------------- SETTINGS ----------------
    const DPI = 72;               // export DPI (true output pixels = inches * DPI)
    const PREVIEW_IN = 6.25;          // preview window is 6.25" x 6.25" (in output inches)
    const PREVIEW_CSS_PX = 420;    // visual size of the preview on screen
    const PREVIEW_PPI = 150;       // preview render PPI (safe on mobile)

    // In-browser bitmap caps (conservative for iOS Safari)
    const MAX_EXPORT_DIM = 8192;           // per-dimension cap
    const MAX_EXPORT_PIXELS = 60_000_000;  // total pixel cap

    // Tiled PDF tile size (inches). Smaller = safer, bigger = faster.
    const PDF_TILE_IN = 6;
    // ------------------------------------------------

    const fileInput = document.getElementById('fileInput');
    const imgInEl = document.getElementById('imgIn');
    const gapInEl = document.getElementById('gapIn');
    const outWInEl = document.getElementById('outWIn');
    const outHInEl = document.getElementById('outHIn');
    const formatEl = document.getElementById('format');

    const hexToggleEl = document.getElementById('hexToggle');
    const circleDiaInEl = document.getElementById('circleDiaIn');

    const renderBtn = document.getElementById('renderBtn');
    const exportBtn = document.getElementById('exportBtn');

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    const imgInfo = document.getElementById('imgInfo');
    const renderInfo = document.getElementById('renderInfo');

    // Cache the original upload
    let originalBitmap = null; // ImageBitmap or HTMLImageElement
    let originalMeta = null;   // { w, h }
    let originalFileBaseName = "Artwork";

    // Preview camera (in OUTPUT inches)
    const previewCam = { xIn: 0, yIn: 0, zoom: 1 };

    // -------- unit parsing: return inches (supports px or inches) --------
    function tryParseToInches(text) {
      const raw = (text ?? "").toString().trim().toLowerCase();
      if (!raw) return null;
      const cleaned = raw.replace(/\s+/g, "");

      const pxMatch = cleaned.match(/^([0-9]*\.?[0-9]+)px$/);
      if (pxMatch) {
        const px = Number(pxMatch[1]);
        return Number.isFinite(px) ? (px / DPI) : null;
      }

      const inchMatch = cleaned.match(/^([0-9]*\.?[0-9]+)(in|inch|inches|")?$/);
      if (inchMatch) {
        const inches = Number(inchMatch[1]);
        return Number.isFinite(inches) ? inches : null;
      }

      return null;
    }

    function parseInchesOrDefault(text, defIn) {
      const v = tryParseToInches(text);
      return (v === null) ? defIn : v;
    }

    function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }

    function clampPreviewCam(outWIn, outHIn) {
      const viewWIn = PREVIEW_IN / previewCam.zoom;
      const viewHIn = PREVIEW_IN / previewCam.zoom;

      const maxX = Math.max(0, outWIn - viewWIn);
      const maxY = Math.max(0, outHIn - viewHIn);

      previewCam.xIn = clamp(previewCam.xIn, 0, maxX);
      previewCam.yIn = clamp(previewCam.yIn, 0, maxY);
    }

    // -------- export cap enforcement (auto-disable png/jpg, auto-select pdf) --------
    function enforceExportCaps(showMsg = false) {
      const outWIn = parseInchesOrDefault(outWInEl.value, 8.5);
      const outHIn = parseInchesOrDefault(outHInEl.value, 11);

      const expWpx = Math.round(outWIn * DPI);
      const expHpx = Math.round(outHIn * DPI);
      const totalPx = expWpx * expHpx;

      const overCap =
        expWpx > MAX_EXPORT_DIM ||
        expHpx > MAX_EXPORT_DIM ||
        totalPx > MAX_EXPORT_PIXELS;

      const pngOpt = formatEl.querySelector('option[value="png"]');
      const jpgOpt = formatEl.querySelector('option[value="jpg"]');
      const pdfOpt = formatEl.querySelector('option[value="pdf"]');

      if (overCap) {
        if (pngOpt) pngOpt.disabled = true;
        if (jpgOpt) jpgOpt.disabled = true;
        if (pdfOpt) pdfOpt.disabled = false;

        if (formatEl.value === "png" || formatEl.value === "jpg") {
          formatEl.value = "pdf";
        }

        if (showMsg) {
          renderInfo.textContent =
            `Output ${outWIn}×${outHIn} in @ ${DPI} DPI = ${expWpx}×${expHpx}px (~${(totalPx/1e6).toFixed(0)} MP). ` +
            `PNG/JPG disabled (browser cap). PDF auto-selected (tiled).`;
        }
      } else {
        if (pngOpt) pngOpt.disabled = false;
        if (jpgOpt) jpgOpt.disabled = false;
      }

      return { overCap, expWpx, expHpx, totalPx, outWIn, outHIn };
    }

    // -------- image load/cache --------
    async function loadAndCacheOriginal(file) {
      originalFileBaseName = (file.name || "Artwork").replace(/\.[^/.]+$/, "");

      if (originalBitmap && typeof originalBitmap.close === "function") {
        try { originalBitmap.close(); } catch {}
      }
      originalBitmap = null;
      originalMeta = null;

      const url = URL.createObjectURL(file);
      try {
        if ("createImageBitmap" in window) {
          const blob = await fetch(url).then(r => r.blob());
          const bmp = await createImageBitmap(blob);
          originalBitmap = bmp;
          originalMeta = { w: bmp.width, h: bmp.height };
          imgInfo.textContent = `Loaded: ${bmp.width}×${bmp.height}px (cached as ImageBitmap).`;
          return;
        }

        await new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => {
            originalBitmap = img;
            originalMeta = {
              w: img.naturalWidth || img.width,
              h: img.naturalHeight || img.height
            };
            imgInfo.textContent = `Loaded: ${originalMeta.w}×${originalMeta.h}px (cached as Image).`;
            resolve();
          };
          img.onerror = reject;
          img.src = url;
        });
      } finally {
        URL.revokeObjectURL(url);
      }
    }

    fileInput.addEventListener("change", async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;

      imgInfo.textContent = "Loading...";
      try {
        await loadAndCacheOriginal(file);
        previewCam.xIn = 0;
        previewCam.yIn = 0;
        previewCam.zoom = 1;
        renderPreview();
      } catch (err) {
        console.error(err);
        originalBitmap = null;
        originalMeta = null;
        imgInfo.textContent = "Failed to load image.";
      }
    });

    // -------- preview canvas setup (always 6"x6") --------
    function setupPreviewCanvas() {
      canvas.style.width = PREVIEW_CSS_PX + "px";
      canvas.style.height = PREVIEW_CSS_PX + "px";

      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.round(PREVIEW_CSS_PX * dpr);
      canvas.height = Math.round(PREVIEW_CSS_PX * dpr);

      ctx.setTransform(1,0,0,1,0,0);
    }

    // -------- draw letterboxed tile at (x,y) in INCHES --------
    function drawLetterboxedTileAtIn(targetCtx, pxPerIn, xIn, yIn, tileIn) {
      if (!originalBitmap || !originalMeta) return;

      const srcW = originalMeta.w;
      const srcH = originalMeta.h;
      const tilePx = tileIn * pxPerIn;

      const scale = Math.min(tilePx / srcW, tilePx / srcH);
      const drawWIn = (srcW * scale) / pxPerIn;
      const drawHIn = (srcH * scale) / pxPerIn;

      const dx = xIn + (tileIn - drawWIn) / 2;
      const dy = yIn + (tileIn - drawHIn) / 2;

      targetCtx.drawImage(originalBitmap, dx, dy, drawWIn, drawHIn);
    }

    // -------- render ONLY a viewport (camera window) --------
    function renderArtworkViewport(targetCtx, pxPerIn, cfg) {
      const { outWIn, outHIn, tileInches, gapIn, hexOn, circleDiaIn, camXIn, camYIn, viewWIn, viewHIn } = cfg;

      const wPx = Math.max(1, Math.round(viewWIn * pxPerIn));
      const hPx = Math.max(1, Math.round(viewHIn * pxPerIn));

      targetCtx.setTransform(1,0,0,1,0,0);
      targetCtx.clearRect(0,0,wPx,hPx);
      targetCtx.fillStyle = "#fff";
      targetCtx.fillRect(0,0,wPx,hPx);

      targetCtx.setTransform(pxPerIn, 0, 0, pxPerIn, 0, 0);
      targetCtx.imageSmoothingEnabled = true;
      targetCtx.imageSmoothingQuality = "high";

      const stepIn = (tileInches + gapIn) / 1.5;

      const startC = Math.floor(camXIn / stepIn) - 2;
      const startR = Math.floor(camYIn / stepIn) - 2;
      const endC   = Math.ceil((camXIn + viewWIn) / stepIn) + 2;
      const endR   = Math.ceil((camYIn + viewHIn) / stepIn) + 2;

      let approxCols = Math.max(0, endC - startC);
      let approxRows = Math.max(0, endR - startR);

      for (let r = startR; r < endR; r++) {
        for (let c = startC; c < endC; c++) {
          if (((r + c) % 2) !== 0) continue;

          const xFull = c * stepIn;
          const yFull = r * stepIn;

          const x = xFull - camXIn;
          const y = yFull - camYIn;

          if (x > viewWIn || y > viewHIn || x + tileInches < 0 || y + tileInches < 0) continue;

          drawLetterboxedTileAtIn(targetCtx, pxPerIn, x, y, tileInches);
        }
      }

      if (hexOn) {
        const dia = circleDiaIn;
        const rr = dia / 2;
        const xStep = dia;
        const yStep = dia * Math.sqrt(3) / 2;

        targetCtx.save();
        targetCtx.lineWidth = Math.max(1/pxPerIn, 0.01);
        targetCtx.globalAlpha = 0.65;

        let row = Math.floor((camYIn - rr) / yStep);
        for (let cyFull = row * yStep; cyFull <= camYIn + viewHIn + rr; cyFull += yStep, row++) {
          const xOffset = (row % 2 === 0) ? 0 : xStep / 2;
          let col = Math.floor((camXIn - rr - xOffset) / xStep);

          for (let cxFull = col * xStep + xOffset; cxFull <= camXIn + viewWIn + rr; cxFull += xStep) {
            const cx = cxFull - camXIn;
            const cy = cyFull - camYIn;

            targetCtx.beginPath();
            targetCtx.arc(cx, cy, rr, 0, Math.PI * 2);
            targetCtx.stroke();
          }
        }

        targetCtx.restore();
      }

      return { wPx, hPx, approxCols, approxRows, stepIn };
    }

    // -------- render FULL output (for bitmap export only, under cap) --------
    function renderArtworkFull(targetCtx, pxPerIn, outWIn, outHIn, tileInches, gapIn, hexOn, circleDiaIn) {
      const wPx = Math.max(1, Math.round(outWIn * pxPerIn));
      const hPx = Math.max(1, Math.round(outHIn * pxPerIn));

      targetCtx.setTransform(1,0,0,1,0,0);
      targetCtx.clearRect(0,0,wPx,hPx);
      targetCtx.fillStyle = "#fff";
      targetCtx.fillRect(0,0,wPx,hPx);

      targetCtx.setTransform(pxPerIn,0,0,pxPerIn,0,0);
      targetCtx.imageSmoothingEnabled = true;
      targetCtx.imageSmoothingQuality = "high";

      const stepIn = (tileInches + gapIn) / 1.5;
      const cols = Math.ceil(outWIn / stepIn);
      const rows = Math.ceil(outHIn / stepIn);

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (((r + c) % 2) !== 0) continue;
          const xIn = c * stepIn;
          const yIn = r * stepIn;
          if (xIn > outWIn || yIn > outHIn) continue;
          drawLetterboxedTileAtIn(targetCtx, pxPerIn, xIn, yIn, tileInches);
        }
      }

      if (hexOn) {
        const dia = circleDiaIn;
        const rr = dia / 2;
        const xStep = dia;
        const yStep = dia * Math.sqrt(3)/2;

        targetCtx.save();
        targetCtx.lineWidth = Math.max(1/pxPerIn, 0.01);
        targetCtx.globalAlpha = 0.65;

        const startY = -rr;
        let row = 0;
        for (let cy = startY; cy <= outHIn + rr; cy += yStep, row++) {
          const xOffset = (row % 2 === 0) ? 0 : xStep/2;
          const startX = -rr + xOffset;
          for (let cx = startX; cx <= outWIn + rr; cx += xStep) {
            targetCtx.beginPath();
            targetCtx.arc(cx, cy, rr, 0, Math.PI*2);
            targetCtx.stroke();
          }
        }

        targetCtx.restore();
      }

      return { cols, rows, stepIn, wPx, hPx };
    }

    // -------- render a TILE region for PDF assembly (safe for huge sizes) --------
    function renderArtworkTile(targetCtx, pxPerIn, cfg) {
      const {
        outWIn, outHIn,
        tileInches, gapIn,
        hexOn, circleDiaIn,
        x0In, y0In, wIn, hIn
      } = cfg;

      const wPx = Math.max(1, Math.round(wIn * pxPerIn));
      const hPx = Math.max(1, Math.round(hIn * pxPerIn));

      targetCtx.setTransform(1,0,0,1,0,0);
      targetCtx.clearRect(0,0,wPx,hPx);
      targetCtx.fillStyle = "#fff";
      targetCtx.fillRect(0,0,wPx,hPx);

      targetCtx.setTransform(pxPerIn,0,0,pxPerIn,0,0);
      targetCtx.imageSmoothingEnabled = true;
      targetCtx.imageSmoothingQuality = "high";

      const stepIn = (tileInches + gapIn) / 1.5;

      const startC = Math.floor(x0In / stepIn) - 2;
      const startR = Math.floor(y0In / stepIn) - 2;
      const endC   = Math.ceil((x0In + wIn) / stepIn) + 2;
      const endR   = Math.ceil((y0In + hIn) / stepIn) + 2;

      for (let r = startR; r < endR; r++) {
        for (let c = startC; c < endC; c++) {
          if (((r + c) % 2) !== 0) continue;

          const xFull = c * stepIn;
          const yFull = r * stepIn;

          const x = xFull - x0In;
          const y = yFull - y0In;

          if (x > wIn || y > hIn || x + tileInches < 0 || y + tileInches < 0) continue;

          drawLetterboxedTileAtIn(targetCtx, pxPerIn, x, y, tileInches);
        }
      }

      if (hexOn) {
        const dia = circleDiaIn;
        const rr = dia / 2;
        const xStep = dia;
        const yStep = dia * Math.sqrt(3) / 2;

        targetCtx.save();
        targetCtx.lineWidth = Math.max(1/pxPerIn, 0.01);
        targetCtx.globalAlpha = 0.65;

        let row = Math.floor((y0In - rr) / yStep);
        for (let cyFull = row * yStep; cyFull <= y0In + hIn + rr; cyFull += yStep, row++) {
          const xOffset = (row % 2 === 0) ? 0 : xStep / 2;
          let col = Math.floor((x0In - rr - xOffset) / xStep);

          for (let cxFull = col * xStep + xOffset; cxFull <= x0In + wIn + rr; cxFull += xStep) {
            const cx = cxFull - x0In;
            const cy = cyFull - y0In;
            targetCtx.beginPath();
            targetCtx.arc(cx, cy, rr, 0, Math.PI * 2);
            targetCtx.stroke();
          }
        }

        targetCtx.restore();
      }
    }

    // -------- PREVIEW RENDER (viewport only; safe on mobile) --------
    function renderPreview() {
      const cap = enforceExportCaps(false);

      const outWIn = cap.outWIn;
      const outHIn = cap.outHIn;
      const tileInches = parseInchesOrDefault(imgInEl.value, 1);
      const gapIn  = Math.max(0, parseInchesOrDefault(gapInEl.value, 0));
      const hexOn  = !!hexToggleEl.checked;
      const circleDiaIn = parseInchesOrDefault(circleDiaInEl.value, 6.25);

      clampPreviewCam(outWIn, outHIn);
      setupPreviewCanvas();

      const viewWIn = PREVIEW_IN / previewCam.zoom;
      const viewHIn = PREVIEW_IN / previewCam.zoom;

      const off = document.createElement("canvas");
      off.width  = Math.max(1, Math.round(viewWIn * PREVIEW_PPI));
      off.height = Math.max(1, Math.round(viewHIn * PREVIEW_PPI));
      const octx = off.getContext("2d");

      const meta = renderArtworkViewport(octx, PREVIEW_PPI, {
        outWIn, outHIn, tileInches, gapIn, hexOn, circleDiaIn,
        camXIn: previewCam.xIn,
        camYIn: previewCam.yIn,
        viewWIn,
        viewHIn
      });

      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(off, 0, 0, canvas.width, canvas.height);

      const parts = [];
      parts.push(`Preview: ${viewWIn.toFixed(2)}"×${viewHIn.toFixed(2)}" (zoom ${previewCam.zoom.toFixed(2)}×).`);
      parts.push(`Pan: x=${previewCam.xIn.toFixed(2)}", y=${previewCam.yIn.toFixed(2)}".`);
      parts.push(`Output: ${outWIn.toFixed(2)}×${outHIn.toFixed(2)} in @ ${DPI} DPI → ${cap.expWpx}×${cap.expHpx}px (~${(cap.totalPx/1e6).toFixed(0)} MP).`);
      parts.push(cap.overCap ? `PNG/JPG disabled → PDF tiled export.` : `PNG/JPG enabled.`);
      parts.push(`Tile: ${tileInches.toFixed(2)}". Gap: ${gapIn.toFixed(2)}".`);
      if (originalMeta) parts.push(`Source: ${originalMeta.w}×${originalMeta.h}px.`);
      else parts.push(`Upload an image to see tiles.`);
      parts.push(hexOn ? `Hex overlay ON (${circleDiaIn.toFixed(2)}").` : `Hex overlay OFF.`);
      parts.push(`Viewport tiles checked ~ ${meta.approxCols}×${meta.approxRows}.`);
      renderInfo.textContent = parts.join(" ");
    }

    // -------- Download helper (best-effort on iOS) --------
    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      a.rel = "noopener";
      document.body.appendChild(a);
      a.click();
      a.remove();

      // fallback open
      setTimeout(() => {
        try { window.open(url, "_blank"); } catch {}
        setTimeout(() => URL.revokeObjectURL(url), 4000);
      }, 250);
    }

    function canvasToBlob(canvasEl, mime, quality) {
      return new Promise((resolve) => canvasEl.toBlob(resolve, mime, quality));
    }
    function u32be(n){ return new Uint8Array([(n>>>24)&255,(n>>>16)&255,(n>>>8)&255,n&255]); }

function crc32(bytes) {
  let c = 0xffffffff;
  for (const b of bytes) {
    c ^= b;
    for (let k=0;k<8;k++) c = (c & 1) ? (0xedb88320 ^ (c >>> 1)) : (c >>> 1);
  }
  return (c ^ 0xffffffff) >>> 0;
}

// --- PNG: inject pHYs chunk for DPI ---
async function setPngDpi(pngBlob, dpi) {
  const buf = new Uint8Array(await pngBlob.arrayBuffer());

  // PNG signature
  const sig = [137,80,78,71,13,10,26,10];
  for (let i=0;i<8;i++) if (buf[i] !== sig[i]) return pngBlob;

  const ppm = Math.round(dpi * 39.37007874); // pixels per meter
  const type = new TextEncoder().encode("pHYs");
  const data = new Uint8Array(9);

  // X ppm
  data[0]=(ppm>>>24)&255; data[1]=(ppm>>>16)&255; data[2]=(ppm>>>8)&255; data[3]=ppm&255;
  // Y ppm
  data[4]=(ppm>>>24)&255; data[5]=(ppm>>>16)&255; data[6]=(ppm>>>8)&255; data[7]=ppm&255;
  data[8]=1; // unit meter

  const crcInput = new Uint8Array(type.length + data.length);
  crcInput.set(type, 0);
  crcInput.set(data, type.length);
  const crc = crc32(crcInput);

  const chunk = new Uint8Array(4 + 4 + data.length + 4);
  chunk.set(u32be(data.length), 0);
  chunk.set(type, 4);
  chunk.set(data, 8);
  chunk.set(u32be(crc), 8 + data.length);

  // insert after IHDR
  const ihdrLen = (buf[8]<<24)|(buf[9]<<16)|(buf[10]<<8)|buf[11];
  const ihdrTotal = 12 + ihdrLen; // len+type+data+crc = 12+dataLen
  const insertAt = 8 + ihdrTotal;

  const out = new Uint8Array(buf.length + chunk.length);
  out.set(buf.slice(0, insertAt), 0);
  out.set(chunk, insertAt);
  out.set(buf.slice(insertAt), insertAt + chunk.length);

  return new Blob([out], { type: "image/png" });
}

// --- JPEG: set JFIF density to DPI (or add JFIF if missing) ---
async function setJpegDpi(jpegBlob, dpi) {
  const buf = new Uint8Array(await jpegBlob.arrayBuffer());

  // must start with SOI
  if (!(buf[0] === 0xFF && buf[1] === 0xD8)) return jpegBlob;

  // find APP0 JFIF marker (FFE0)
  let i = 2;
  while (i + 4 < buf.length) {
    if (buf[i] !== 0xFF) break;
    const marker = buf[i+1];
    // SOS or EOI stops header scan
    if (marker === 0xDA || marker === 0xD9) break;

    const len = (buf[i+2] << 8) | buf[i+3];
    if (marker === 0xE0 && i + 4 + len <= buf.length) {
      // Check "JFIF\0"
      const id = buf.slice(i+4, i+9);
      const isJFIF = id[0]===0x4A && id[1]===0x46 && id[2]===0x49 && id[3]===0x46 && id[4]===0x00;
      if (isJFIF) {
        // JFIF layout: [i+4..] "JFIF\0" (5)
        // version (2) @ i+9,i+10
        // units (1) @ i+11 (0=none,1=dpi,2=dpcm)
        // Xdensity (2) @ i+12,i+13
        // Ydensity (2) @ i+14,i+15
        const out = buf.slice(); // copy
        out[i+11] = 1; // dpi
        out[i+12] = (dpi >>> 8) & 255;
        out[i+13] = dpi & 255;
        out[i+14] = (dpi >>> 8) & 255;
        out[i+15] = dpi & 255;
        return new Blob([out], { type: "image/jpeg" });
      }
    }
    i += 2 + len;
  }

  // If no JFIF found, add a minimal APP0 JFIF segment after SOI
  const app0 = new Uint8Array(18);
  app0[0]=0xFF; app0[1]=0xE0; // APP0
  app0[2]=0x00; app0[3]=0x10; // length=16 bytes after length field
  // "JFIF\0"
  app0[4]=0x4A; app0[5]=0x46; app0[6]=0x49; app0[7]=0x46; app0[8]=0x00;
  // version 1.01
  app0[9]=0x01; app0[10]=0x01;
  // units=dpi
  app0[11]=0x01;
  // Xdensity, Ydensity
  app0[12]=(dpi>>>8)&255; app0[13]=dpi&255;
  app0[14]=(dpi>>>8)&255; app0[15]=dpi&255;
  // Xthumbnail, Ythumbnail
  app0[16]=0x00; app0[17]=0x00;

  const out = new Uint8Array(buf.length + app0.length);
  out.set(buf.slice(0,2), 0);
  out.set(app0, 2);
  out.set(buf.slice(2), 2 + app0.length);

  return new Blob([out], { type: "image/jpeg" });
}
    // -------- EXPORT: bitmap under cap, otherwise tiled PDF --------
    async function exportNow() {
      const cap = enforceExportCaps(true);
      const outWIn = cap.outWIn;
      const outHIn = cap.outHIn;

      const tileInches = parseInchesOrDefault(imgInEl.value, 1);
      const gapIn  = Math.max(0, parseInchesOrDefault(gapInEl.value, 0));
      const hexOn  = !!hexToggleEl.checked;
      const circleDiaIn = parseInchesOrDefault(circleDiaInEl.value, 6.25);

      const base = `${originalFileBaseName} Random Pattern`;

      // Auto force PDF when over cap
      if (cap.overCap) formatEl.value = "pdf";

      const fmt = formatEl.value;

      // Bitmap export only if under cap
      if (!cap.overCap && (fmt === "png" || fmt === "jpg")) {
      const exp = document.createElement("canvas");
      exp.width = cap.expWpx;
      exp.height = cap.expHpx;
    
      const ectx = exp.getContext("2d");
      renderArtworkFull(ectx, DPI, outWIn, outHIn, tileInches, gapIn, hexOn, circleDiaIn);
    
      if (fmt === "png") {
        let blob = await canvasToBlob(exp, "image/png", 1.0);
        if (!blob) { renderInfo.textContent = "PNG export failed (null blob)."; return; }
        blob = await setPngDpi(blob, DPI);
        downloadBlob(blob, `${base}.png`);
        return;
      } else {
        let blob = await canvasToBlob(exp, "image/jpeg", 0.9);
        if (!blob) { renderInfo.textContent = "JPG export failed (null blob)."; return; }
        blob = await setJpegDpi(blob, DPI);
        downloadBlob(blob, `${base}.jpg`);
        return;
      }
    }

      // Tiled PDF (works for huge sizes like 50x96)
      const { jsPDF } = window.jspdf || {};
      if (!jsPDF) {
        renderInfo.textContent = "PDF export failed: jsPDF not loaded.";
        return;
      }

      const pdf = new jsPDF({
        orientation: (outWIn >= outHIn) ? "landscape" : "portrait",
        unit: "in",
        format: [outWIn, outHIn]
      });

      const tileIn = PDF_TILE_IN;
      const cols = Math.ceil(outWIn / tileIn);
      const rows = Math.ceil(outHIn / tileIn);

      const tileCanvas = document.createElement("canvas");
      let tctx = tileCanvas.getContext("2d");

      let count = 0;
      const total = cols * rows;

      renderInfo.textContent = `Tiled PDF export: ${cols}×${rows} tiles (${tileIn}" each).`;

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const x0 = c * tileIn;
          const y0 = r * tileIn;
          const wIn = Math.min(tileIn, outWIn - x0);
          const hIn = Math.min(tileIn, outHIn - y0);

          const wPx = Math.max(1, Math.round(wIn * DPI));
          const hPx = Math.max(1, Math.round(hIn * DPI));

          if (tileCanvas.width !== wPx) tileCanvas.width = wPx;
          if (tileCanvas.height !== hPx) tileCanvas.height = hPx;
          tctx = tileCanvas.getContext("2d");

          renderArtworkTile(tctx, DPI, {
            outWIn, outHIn,
            tileInches, gapIn,
            hexOn, circleDiaIn,
            x0In: x0, y0In: y0, wIn, hIn
          });

          const dataUrl = tileCanvas.toDataURL("image/png"); // tile-sized => safe
          pdf.addImage(dataUrl, "PNG", x0, y0, wIn, hIn);

          count++;
          if (count % 10 === 0) {
            renderInfo.textContent = `Tiled PDF export: ${count}/${total} tiles...`;
          }
        }
      }

      pdf.save(`${base}.pdf`);
      renderInfo.textContent = "Tiled PDF export started.";
    }

    // -------- PAN + ZOOM (preview only) --------
    let isPanning = false;
    let panStart = null;

    canvas.addEventListener("pointerdown", (e) => {
      canvas.setPointerCapture(e.pointerId);
      isPanning = true;
      panStart = { x: e.clientX, y: e.clientY, camX: previewCam.xIn, camY: previewCam.yIn };
    });

    canvas.addEventListener("pointermove", (e) => {
      if (!isPanning || !panStart) return;

      const outWIn = parseInchesOrDefault(outWInEl.value, 8.5);
      const outHIn = parseInchesOrDefault(outHInEl.value, 11);

      const rect = canvas.getBoundingClientRect();
      const pxPerInCss = rect.width / PREVIEW_IN;

      const dxInPreview = (e.clientX - panStart.x) / pxPerInCss;
      const dyInPreview = (e.clientY - panStart.y) / pxPerInCss;

      const dxOut = dxInPreview / previewCam.zoom;
      const dyOut = dyInPreview / previewCam.zoom;

      previewCam.xIn = panStart.camX - dxOut;
      previewCam.yIn = panStart.camY - dyOut;

      clampPreviewCam(outWIn, outHIn);
      renderPreview();
    });

    function endPan() { isPanning = false; panStart = null; }
    canvas.addEventListener("pointerup", endPan);
    canvas.addEventListener("pointercancel", endPan);

    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const outWIn = parseInchesOrDefault(outWInEl.value, 8.5);
      const outHIn = parseInchesOrDefault(outHInEl.value, 11);

      const factor = (e.deltaY < 0) ? 1.12 : (1 / 1.12);
      previewCam.zoom = clamp(previewCam.zoom * factor, 1, 8);

      clampPreviewCam(outWIn, outHIn);
      renderPreview();
    }, { passive: false });

    // Mobile pinch zoom (two pointers)
    const activePointers = new Map();
    let pinchStart = null;

    function dist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }

    canvas.addEventListener("pointerdown", (e) => {
      activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
      if (activePointers.size === 2) {
        const pts = Array.from(activePointers.values());
        pinchStart = { d: dist(pts[0], pts[1]), zoom: previewCam.zoom };
      }
    });

    canvas.addEventListener("pointermove", (e) => {
      if (!activePointers.has(e.pointerId)) return;
      activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

      if (activePointers.size === 2 && pinchStart) {
        const outWIn = parseInchesOrDefault(outWInEl.value, 8.5);
        const outHIn = parseInchesOrDefault(outHInEl.value, 11);

        const pts = Array.from(activePointers.values());
        const dNow = dist(pts[0], pts[1]);
        if (pinchStart.d > 0) {
          const ratio = dNow / pinchStart.d;
          previewCam.zoom = clamp(pinchStart.zoom * ratio, 1, 8);
          clampPreviewCam(outWIn, outHIn);
          renderPreview();
        }
      }
    });

    canvas.addEventListener("pointerup", (e) => {
      activePointers.delete(e.pointerId);
      if (activePointers.size < 2) pinchStart = null;
    });
    canvas.addEventListener("pointercancel", (e) => {
      activePointers.delete(e.pointerId);
      if (activePointers.size < 2) pinchStart = null;
    });

    // -------- Buttons --------
    renderBtn.addEventListener('click', renderPreview);
    exportBtn.addEventListener('click', exportNow);

    // Update cap state when typing sizes
    [outWInEl, outHInEl].forEach(el => {
      el.addEventListener("input", () => enforceExportCaps(true));
    });

    // Initial draw
    enforceExportCaps(false);
    renderPreview();
  </script>
</body>
</html>
