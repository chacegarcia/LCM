<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HP Artwork Generator (400 DPI, HQ)</title>
  <style>
    :root { --gap: 16px; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; }
    .wrap { display: grid; grid-template-columns: 360px 1fr; gap: var(--gap); padding: var(--gap); align-items: start; }
    .panel {
      border: 1px solid #e6e6e6; border-radius: 12px; padding: 14px; position: sticky; top: 12px;
      background: #fff;
    }
    .field { margin-bottom: 12px; }
    label { display: block; font-size: 12px; opacity: 0.85; margin-bottom: 6px; }
    input[type="text"], select, button {
      font-size: 14px; padding: 9px 10px; width: 100%;
      border: 1px solid #d9d9d9; border-radius: 10px; background: #fff;
      box-sizing: border-box;
    }
    input[type="checkbox"] { transform: scale(1.1); }
    button { cursor: pointer; }
    .btnRow { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; }
    .meta { font-size: 12px; opacity: 0.8; line-height: 1.35; margin-top: 8px; }
    .stage {
      border: 1px solid #e6e6e6; border-radius: 12px; padding: 14px; background: #fff;
      overflow: auto;
    }
    canvas { border: 1px solid #cfcfcf; display: block; max-width: 100%; height: auto; }
    .hint { font-size: 12px; opacity: 0.75; margin-bottom: 10px; }
    .row2 { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .toggleLine { display: flex; gap: 10px; align-items: center; padding: 8px 10px; border: 1px solid #d9d9d9; border-radius: 10px; }
    .toggleLine span { font-size: 14px; }
  </style>
</head>
<body>
  <div class="wrap">
    <!-- LEFT COLUMN -->
    <div class="panel">
      <div class="field">
        <label>Upload image (any size)</label>
        <input id="fileInput" type="file" accept="image/*" />
        <div class="meta" id="imgInfo">No image loaded.</div>
      </div>

      <div class="field">
        <label>Tile size (inches) @ 400 DPI</label>
        <input id="imgIn" type="text" value='1"' />
      </div>

      <div class="field">
        <label>Gap around each cell (inches)</label>
        <input id="gapIn" type="text" value='0"' />
      </div>
		
	  <!-- div class="field">
        <label>Closeness Between Logos(Divisor)</label>
        <input id="Tight" type="text" value='1.5"' />
	</div -->

      <div class="row2">
        <div class="field">
          <label>Final width (inches)</label>
          <input id="outWIn" type="text" value='8.5"' />
        </div>
        <div class="field">
          <label>Final height (inches)</label>
          <input id="outHIn" type="text" value='11"' />
        </div>
      </div>

      <div class="field">
        <label>Hex-packed circle overlay</label>
        <div class="toggleLine">
          <input id="hexToggle" type="checkbox" />
          <span>Show hex-packed circles</span>
        </div>
        <div style="height:10px;"></div>
        <label>Circle diameter (inches)</label>
        <input id="circleDiaIn" type="text" value='6.25"' />
      </div>

      <div class="field">
        <label>Export format</label>
        <select id="format">
          <option value="png">PNG</option>
          <option value="jpg">JPG</option>
          <option value="pdf">PDF</option>
        </select>
      </div>

      <div class="btnRow">
        <button id="renderBtn">Reload Canvas</button>
        <button id="exportBtn">Export</button>
      </div>

      <div class="meta" id="renderInfo">
        Tip: Edit inputs freely, then click <b>Reload Canvas</b> to redraw.
      </div>
    </div>

    <!-- RIGHT COLUMN -->
    <div class="stage">
      <div class="hint">
        Preview canvas redraws only when you click <b>Reload Canvas</b> (or after image upload / export).
      </div>
      <canvas id="canvas"></canvas>
    </div>
  </div>

  <!-- jsPDF for PDF export -->
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <!-- <script type="module" src="https://github.com/chacegarcia/LCM/index.js"></script> -->

<script>
  const DPI = 400;                 // export DPI (true pixels = inches * DPI)
  const PREVIEW_IN = 6;            // preview canvas represents 6" x 6" space
  const PREVIEW_CSS_PX = 420;      // how big the preview looks on screen (pick any)

  const fileInput = document.getElementById('fileInput');
  const imgInEl = document.getElementById('imgIn');
  const gapInEl = document.getElementById('gapIn');
  const outWInEl = document.getElementById('outWIn');
  const outHInEl = document.getElementById('outHIn');
  const formatEl = document.getElementById('format');

  const hexToggleEl = document.getElementById('hexToggle');
  const circleDiaInEl = document.getElementById('circleDiaIn');

  const renderBtn = document.getElementById('renderBtn');
  const exportBtn = document.getElementById('exportBtn');

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  const imgInfo = document.getElementById('imgInfo');
  const renderInfo = document.getElementById('renderInfo');

  // Cache the original upload
  let originalBitmap = null; // ImageBitmap or HTMLImageElement
  let originalMeta = null;   // { w, h }
  let originalFileBaseName = "Artwork";

  // ---------- units parsing ----------
  function tryParseToInches(text) {
    const raw = (text ?? "").toString().trim().toLowerCase();
    if (!raw) return null;
    const cleaned = raw.replace(/\s+/g, "");

    // px: 400px  -> inches = px / DPI
    const pxMatch = cleaned.match(/^([0-9]*\.?[0-9]+)px$/);
    if (pxMatch) {
      const px = Number(pxMatch[1]);
      return Number.isFinite(px) ? (px / DPI) : null;
    }

    // inches: 2, 2", 2in, .5"
    const inchMatch = cleaned.match(/^([0-9]*\.?[0-9]+)(in|inch|inches|")?$/);
    if (inchMatch) {
      const inches = Number(inchMatch[1]);
      return Number.isFinite(inches) ? inches : null;
    }
    return null;
  }

  function parseInchesOrDefault(text, defIn) {
    const v = tryParseToInches(text);
    return (v === null) ? defIn : v;
  }

  function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }

  // ---------- image load ----------
  async function loadAndCacheOriginal(file) {
    originalFileBaseName = (file.name || "Artwork").replace(/\.[^/.]+$/, "");

    if (originalBitmap && typeof originalBitmap.close === "function") {
      try { originalBitmap.close(); } catch {}
    }
    originalBitmap = null;
    originalMeta = null;

    const url = URL.createObjectURL(file);
    try {
      if ("createImageBitmap" in window) {
        const blob = await fetch(url).then(r => r.blob());
        const bmp = await createImageBitmap(blob);
        originalBitmap = bmp;
        originalMeta = { w: bmp.width, h: bmp.height };
        imgInfo.textContent = `Loaded: ${bmp.width}×${bmp.height}px (cached as ImageBitmap).`;
        return;
      }

      await new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
          originalBitmap = img;
          originalMeta = {
            w: img.naturalWidth || img.width,
            h: img.naturalHeight || img.height
          };
          imgInfo.textContent = `Loaded: ${originalMeta.w}×${originalMeta.h}px (cached as Image).`;
          resolve();
        };
        img.onerror = reject;
        img.src = url;
      });
    } finally {
      URL.revokeObjectURL(url);
    }
  }

  fileInput.addEventListener("change", async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;

    imgInfo.textContent = "Loading...";
    try {
      await loadAndCacheOriginal(file);
      renderPreview();
    } catch (err) {
      console.error(err);
      originalBitmap = null;
      originalMeta = null;
      imgInfo.textContent = "Failed to load image.";
    }
  });

  // ---------- core renderer (draws in INCHES) ----------
  // This is the key: one renderer used for preview AND export.
  function renderArtworkToContext(targetCtx, pxPerIn, outWIn, outHIn, tileIn, gapIn, hexOn, circleDiaIn) {
    const wPx = Math.max(1, Math.round(outWIn * pxPerIn));
    const hPx = Math.max(1, Math.round(outHIn * pxPerIn));

    // Clear + white background
    targetCtx.setTransform(1, 0, 0, 1, 0, 0);
    targetCtx.clearRect(0, 0, wPx, hPx);
    targetCtx.fillStyle = "#fff";
    targetCtx.fillRect(0, 0, wPx, hPx);

    // Draw using inch-units: transform inches -> pixels
    targetCtx.setTransform(pxPerIn, 0, 0, pxPerIn, 0, 0);
    targetCtx.imageSmoothingEnabled = true;
    targetCtx.imageSmoothingQuality = "high";

    // Helpers in inch-space
    function drawLetterboxedTileAtIn(xIn, yIn, tileInches) {
      if (!originalBitmap || !originalMeta) return;

      const srcW = originalMeta.w;
      const srcH = originalMeta.h;

      const tilePx = tileInches * pxPerIn;

      const scale = Math.min(tilePx / srcW, tilePx / srcH);
      const drawW = (srcW * scale) / pxPerIn; // back to inches for drawImage transform
      const drawH = (srcH * scale) / pxPerIn;

      const dx = xIn + (tileInches - drawW) / 2;
      const dy = yIn + (tileInches - drawH) / 2;

      targetCtx.drawImage(originalBitmap, dx, dy, drawW, drawH);
    }

    function drawCheckerboardTilesIn() {
      if (!originalBitmap || !originalMeta) return null;

      const stepIn = (tileIn + gapIn) / 1.5;
      const cols = Math.ceil(outWIn / stepIn);
      const rows = Math.ceil(outHIn / stepIn);

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (((r + c) % 2) !== 0) continue;

          const xIn = c * stepIn;
          const yIn = r * stepIn;
          if (xIn > outWIn || yIn > outHIn) continue;

          drawLetterboxedTileAtIn(xIn, yIn, tileIn);
        }
      }
      return { cols, rows, stepIn };
    }

    function drawHexCircleOverlayIn() {
      const dia = circleDiaIn;
      const r = dia / 2;
      const xStep = dia;
      const yStep = dia * Math.sqrt(3) / 2;

      targetCtx.save();
      targetCtx.lineWidth = Math.max(1 / pxPerIn, 0.01); // ~0.01" min
      targetCtx.globalAlpha = 0.65;

      const startY = -r;
      let row = 0;

      for (let cy = startY; cy <= outHIn + r; cy += yStep, row++) {
        const xOffset = (row % 2 === 0) ? 0 : xStep / 2;
        const startX = -r + xOffset;

        for (let cx = startX; cx <= outWIn + r; cx += xStep) {
          targetCtx.beginPath();
          targetCtx.arc(cx, cy, r, 0, Math.PI * 2);
          targetCtx.stroke();
        }
      }

      targetCtx.restore();
    }

    const tileMeta = drawCheckerboardTilesIn();
    if (hexOn) drawHexCircleOverlayIn();

    // return info for UI
    return { wPx, hPx, tileMeta };
  }

  // ---------- preview setup (6" x 6") ----------
  function setupPreviewCanvas() {
    canvas.style.width = PREVIEW_CSS_PX + "px";
    canvas.style.height = PREVIEW_CSS_PX + "px";

    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.round(PREVIEW_CSS_PX * dpr);
    canvas.height = Math.round(PREVIEW_CSS_PX * dpr);

    // draw in device pixels; we'll control transforms ourselves
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    return { dpr };
  }

  function renderPreview() {
    const outWIn = parseInchesOrDefault(outWInEl.value, 8.5);
    const outHIn = parseInchesOrDefault(outHInEl.value, 11);
    const tileIn = parseInchesOrDefault(imgInEl.value, 1);
    const gapIn = Math.max(0, parseInchesOrDefault(gapInEl.value, 0));

    const hexOn = !!hexToggleEl.checked;
    const circleDiaIn = parseInchesOrDefault(circleDiaInEl.value, 6.25);

    const { dpr } = setupPreviewCanvas();

    // preview “pixels per inch” (in device pixels) for a 6" wide preview
    const previewPxPerIn = (canvas.width / PREVIEW_IN);

    // Fit the *output* into the 6"x6" preview area (letterbox)
    const fitScale = Math.min(PREVIEW_IN / outWIn, PREVIEW_IN / outHIn);
    const drawWIn = outWIn * fitScale;
    const drawHIn = outHIn * fitScale;
    const offsetXIn = (PREVIEW_IN - drawWIn) / 2;
    const offsetYIn = (PREVIEW_IN - drawHIn) / 2;

    // Clear preview background
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "#fff";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Now render the artwork into a virtual output-size surface,
    // but mapped into the 6"x6" preview by adjusting pxPerIn and translating.
    // We'll do this by temporarily shifting origin and scaling inches.
    ctx.save();
    // inches -> device pixels, with fit scale and offset
    ctx.setTransform(previewPxPerIn, 0, 0, previewPxPerIn, 0, 0);
    ctx.translate(offsetXIn, offsetYIn);
    ctx.scale(fitScale, fitScale);

    // Use the core renderer with the preview's pxPerIn in the *current* transform:
    // Our core renderer sets its own transform, so instead we render to an offscreen
    // at preview resolution of the OUTPUT and then draw it into the transformed preview.
    ctx.restore();

    // Offscreen just for preview-of-output (fast enough, still not your “export backend”)
    const prevOut = document.createElement("canvas");
    const prevPxPerInOut = previewPxPerIn * fitScale;
    prevOut.width = Math.max(1, Math.round(outWIn * prevPxPerInOut));
    prevOut.height = Math.max(1, Math.round(outHIn * prevPxPerInOut));
    const pctx = prevOut.getContext("2d");

    const info = renderArtworkToContext(
      pctx,
      prevPxPerInOut,
      outWIn, outHIn,
      tileIn, gapIn,
      hexOn, circleDiaIn
    );

    // Draw into preview canvas letterboxed
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    const dx = Math.round(offsetXIn * previewPxPerIn);
    const dy = Math.round(offsetYIn * previewPxPerIn);
    const dw = Math.round(drawWIn * previewPxPerIn);
    const dh = Math.round(drawHIn * previewPxPerIn);
    ctx.drawImage(prevOut, dx, dy, dw, dh);

    // UI text
    const parts = [];
    parts.push(`Preview: ${PREVIEW_IN}"×${PREVIEW_IN}" (letterboxed).`);
    parts.push(`Output: ${outWIn.toFixed(2)}×${outHIn.toFixed(2)} in.`);
    parts.push(`Tile: ${tileIn.toFixed(2)}". Gap: ${gapIn.toFixed(2)}".`);
    parts.push(`Export DPI: ${DPI}. Export pixels: ${Math.round(outWIn*DPI)}×${Math.round(outHIn*DPI)}.`);
    if (originalMeta) parts.push(`Source: ${originalMeta.w}×${originalMeta.h}px.`);
    else parts.push(`Upload an image to see tiles.`);
    if (info?.tileMeta) parts.push(`Grid approx: ${info.tileMeta.cols}×${info.tileMeta.rows}.`);
    parts.push(hexOn ? `Hex overlay ON (${circleDiaIn.toFixed(2)}").` : `Hex overlay OFF.`);
    renderInfo.textContent = parts.join(" ");
  }

  // ---------- export backend renderer ----------
  function downloadBlob(blob, filename) {
    const a = document.createElement("a");
    const url = URL.createObjectURL(blob);
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1500);
  }

  async function exportNow() {
    // Always refresh preview (but export uses backend render)
    renderPreview();

    const outWIn = parseInchesOrDefault(outWInEl.value, 8.5);
    const outHIn = parseInchesOrDefault(outHInEl.value, 11);
    const tileIn = parseInchesOrDefault(imgInEl.value, 1);
    const gapIn = Math.max(0, parseInchesOrDefault(gapInEl.value, 0));

    const hexOn = !!hexToggleEl.checked;
    const circleDiaIn = parseInchesOrDefault(circleDiaInEl.value, 6.25);

    const fmt = formatEl.value;
    const base = `${originalFileBaseName} Random Pattern`;

    // Backend/offscreen canvas at TRUE export DPI
    const exp = document.createElement("canvas");
    exp.width = Math.max(1, Math.round(outWIn * DPI));
    exp.height = Math.max(1, Math.round(outHIn * DPI));
    const ectx = exp.getContext("2d");

    renderArtworkToContext(
      ectx,
      DPI,
      outWIn, outHIn,
      tileIn, gapIn,
      hexOn, circleDiaIn
    );

    if (fmt === "png") {
      exp.toBlob((blob) => blob && downloadBlob(blob, `${base}.png`), "image/png", 1.0);
      return;
    }

    if (fmt === "jpg") {
      exp.toBlob((blob) => blob && downloadBlob(blob, `${base}.jpg`), "image/jpeg", 0.95);
      return;
    }

    if (fmt === "pdf") {
      const { jsPDF } = window.jspdf;

      // Use inches directly so page size is correct
      const pdf = new jsPDF({
        orientation: (outWIn >= outHIn) ? "landscape" : "portrait",
        unit: "in",
        format: [outWIn, outHIn]
      });

      const dataUrl = exp.toDataURL("image/png"); // backend render
      pdf.addImage(dataUrl, "PNG", 0, 0, outWIn, outHIn);
      pdf.save(`${base}.pdf`);
      return;
    }
  }

  // Buttons
  exportBtn.addEventListener('click', exportNow);
  renderBtn.addEventListener('click', renderPreview);

  // Initial preview
  renderPreview();
</script>
</body>
</html>
