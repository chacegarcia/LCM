<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HP Artwork Generator (400 DPI, HQ)</title>
  <style>
    :root { --gap: 16px; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; }
    .wrap { display: grid; grid-template-columns: 360px 1fr; gap: var(--gap); padding: var(--gap); align-items: start; }
    .panel {
      border: 1px solid #e6e6e6; border-radius: 12px; padding: 14px; position: sticky; top: 12px;
      background: #fff;
    }
    .field { margin-bottom: 12px; }
    label { display: block; font-size: 12px; opacity: 0.85; margin-bottom: 6px; }
    input[type="text"], select, button {
      font-size: 14px; padding: 9px 10px; width: 100%;
      border: 1px solid #d9d9d9; border-radius: 10px; background: #fff;
      box-sizing: border-box;
    }
    input[type="checkbox"] { transform: scale(1.1); }
    button { cursor: pointer; }
    .btnRow { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; }
    .meta { font-size: 12px; opacity: 0.8; line-height: 1.35; margin-top: 8px; }
    .stage {
      border: 1px solid #e6e6e6; border-radius: 12px; padding: 14px; background: #fff;
      overflow: auto;
    }
    canvas { border: 1px solid #cfcfcf; display: block; max-width: 100%; height: auto; }
    .hint { font-size: 12px; opacity: 0.75; margin-bottom: 10px; }
    .row2 { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .toggleLine { display: flex; gap: 10px; align-items: center; padding: 8px 10px; border: 1px solid #d9d9d9; border-radius: 10px; }
    .toggleLine span { font-size: 14px; }
  </style>
</head>
<body>
  <div class="wrap">
    <!-- LEFT COLUMN -->
    <div class="panel">
      <div class="field">
        <label>Upload image (any size)</label>
        <input id="fileInput" type="file" accept="image/*" />
        <div class="meta" id="imgInfo">No image loaded.</div>
      </div>

      <div class="field">
        <label>Tile size (inches) @ 400 DPI</label>
        <input id="imgIn" type="text" value='1"' />
      </div>

      <div class="field">
        <label>Gap around each cell (inches)</label>
        <input id="gapIn" type="text" value='0"' />
      </div>

      <div class="row2">
        <div class="field">
          <label>Final width (inches)</label>
          <input id="outWIn" type="text" value='8.5"' />
        </div>
        <div class="field">
          <label>Final height (inches)</label>
          <input id="outHIn" type="text" value='11"' />
        </div>
      </div>

      <div class="field">
        <label>Hex-packed circle overlay</label>
        <div class="toggleLine">
          <input id="hexToggle" type="checkbox" />
          <span>Show hex-packed circles</span>
        </div>
        <div style="height:10px;"></div>
        <label>Circle diameter (inches)</label>
        <input id="circleDiaIn" type="text" value='6.25"' />
      </div>

      <div class="field">
        <label>Export format</label>
        <select id="format">
          <option value="png">PNG</option>
          <option value="jpg">JPG</option>
          <option value="pdf">PDF</option>
        </select>
      </div>

      <div class="btnRow">
        <button id="renderBtn">Reload Canvas</button>
        <button id="exportBtn">Export</button>
      </div>

      <div class="meta" id="renderInfo">
        Tip: Edit inputs freely, then click <b>Reload Canvas</b> to redraw.
      </div>
    </div>

    <!-- RIGHT COLUMN -->
    <div class="stage">
      <div class="hint">
        Preview canvas redraws only when you click <b>Reload Canvas</b> (or after image upload / export).
      </div>
      <canvas id="canvas"></canvas>
    </div>
  </div>

  <!-- jsPDF for PDF export -->
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/changedpi@1.0.4/dist/index.min.js"></script>
  <script type="module">
	  // Now you can import directly from the CDN without errors
	  import { changeDpiDataUrl } from 'https://esm.sh';
	
	  // Your canvas logic here...
	  
	  const DPI = 400;
	  const ExPPI = changeDpiDataUrl(canvas.toDataURL(), DPI);
  </script>  
	  <script>

    const fileInput = document.getElementById('fileInput');
    const imgInEl = document.getElementById('imgIn');
    const gapInEl = document.getElementById('gapIn');
    const outWInEl = document.getElementById('outWIn');
    const outHInEl = document.getElementById('outHIn');
    const formatEl = document.getElementById('format');

    const hexToggleEl = document.getElementById('hexToggle');
    const circleDiaInEl = document.getElementById('circleDiaIn');

    const renderBtn = document.getElementById('renderBtn');
    const exportBtn = document.getElementById('exportBtn');

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    const imgInfo = document.getElementById('imgInfo');
    const renderInfo = document.getElementById('renderInfo');

    // Cache the original upload
    let originalBitmap = null; // ImageBitmap or HTMLImageElement
    let originalMeta = null;   // { w, h }

    // Base filename for exports
    let originalFileBaseName = "Artwork";

    // Returns null if input is empty/invalid while typing (prevents 0px issues)
    function tryParseMeasureToPx(text) {
      const raw = (text ?? "").toString().trim().toLowerCase();
      if (!raw) return null;

      const cleaned = raw.replace(/\s+/g, "");

      // px: 400px
      const pxMatch = cleaned.match(/^([0-9]*\.?[0-9]+)px$/);
      if (pxMatch) {
        const px = Number(pxMatch[1]);
        return Number.isFinite(px) ? Math.round(px) : null;
      }

      // inches: 2, 2", 2in, 2inch, 2inches, .5, .5"
      const inchMatch = cleaned.match(/^([0-9]*\.?[0-9]+)(in|inch|inches|")?$/);
      if (inchMatch) {
        const inches = Number(inchMatch[1]);
        return Number.isFinite(inches) ? Math.round(inches * DPI) : null;
      }

      return null;
    }

    function parseMeasureToPxOrDefault(text, defaultInches) {
      const px = tryParseMeasureToPx(text);
      return (px === null) ? Math.round(defaultInches * DPI) : px;
    }

    function parseMeasureToInchesForInfo(text, defaultInches) {
      const raw = (text ?? "").toString().trim().toLowerCase();
      if (!raw) return defaultInches;

      const cleaned = raw.replace(/\s+/g, "");

      const pxMatch = cleaned.match(/^([0-9]*\.?[0-9]+)px$/);
      if (pxMatch) {
        const px = Number(pxMatch[1]);
        return Number.isFinite(px) ? (px / DPI) : defaultInches;
      }

      const inchMatch = cleaned.match(/^([0-9]*\.?[0-9]+)(in|inch|inches|")?$/);
      if (inchMatch) {
        const inches = Number(inchMatch[1]);
        return Number.isFinite(inches) ? inches : defaultInches;
      }

      return defaultInches;
    }

    async function loadAndCacheOriginal(file) {
      // Save filename without extension for export naming
      originalFileBaseName = (file.name || "Artwork").replace(/\.[^/.]+$/, "");

      // If we had an ImageBitmap before, close it (frees memory)
      if (originalBitmap && typeof originalBitmap.close === "function") {
        try { originalBitmap.close(); } catch {}
      }
      originalBitmap = null;
      originalMeta = null;

      const url = URL.createObjectURL(file);
      try {
        if ("createImageBitmap" in window) {
          const blob = await fetch(url).then(r => r.blob());
          const bmp = await createImageBitmap(blob);
          originalBitmap = bmp;
          originalMeta = { w: bmp.width, h: bmp.height };
          imgInfo.textContent = `Loaded: ${bmp.width}×${bmp.height}px (cached as ImageBitmap).`;
          return;
        }

        await new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => {
            originalBitmap = img;
            originalMeta = {
              w: img.naturalWidth || img.width,
              h: img.naturalHeight || img.height
            };
            imgInfo.textContent = `Loaded: ${originalMeta.w}×${originalMeta.h}px (cached as Image).`;
            resolve();
          };
          img.onerror = reject;
          img.src = url;
        });
      } finally {
        URL.revokeObjectURL(url);
      }
    }

    fileInput.addEventListener("change", async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;

      imgInfo.textContent = "Loading...";
      try {
        await loadAndCacheOriginal(file);
        // Draw once after upload so you get a preview without needing to click
        render();
      } catch (err) {
        console.error(err);
        originalBitmap = null;
        originalMeta = null;
        imgInfo.textContent = "Failed to load image.";
      }
    });

    // Draw original image letterboxed into a square tile (no stretching), scaled directly from original each draw
    function drawLetterboxedTileAt(x, y, tilePx) {
      const srcW = originalMeta.w;
      const srcH = originalMeta.h;

      const scale = Math.min(tilePx / srcW, tilePx / srcH);
      const drawW = srcW * scale;
      const drawH = srcH * scale;

      const dx = x + (tilePx - drawW) / 2;
      const dy = y + (tilePx - drawH) / 2;

      ctx.drawImage(originalBitmap, dx, dy, drawW, drawH);
    }

    function drawCheckerboardTiles(wPx, hPx, tilePx, gapPx) {
      const stepPx = tilePx + gapPx;
      const cols = Math.ceil(wPx / stepPx);
      const rows = Math.ceil(hPx / stepPx);

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (((r + c) % 2) !== 0) continue;

          const x = c * stepPx;
          const y = r * stepPx;
          if (x > wPx || y > hPx) continue;

          drawLetterboxedTileAt(x, y, tilePx);
        }
      }

      return { cols, rows, stepPx };
    }

    function drawHexCircleOverlay(wPx, hPx, diaPx) {
      const r = diaPx / 2;
      const xStep = diaPx;
      const yStep = diaPx * Math.sqrt(3) / 2;

      ctx.save();
      ctx.lineWidth = Math.max(1, Math.round(DPI * 0.01)); // ~0.01"
      ctx.globalAlpha = 0.65;

      const startY = -r;
      let row = 0;

      for (let cy = startY; cy <= hPx + r; cy += yStep, row++) {
        const xOffset = (row % 2 === 0) ? 0 : xStep / 2;
        const startX = -r + xOffset;

        for (let cx = startX; cx <= wPx + r; cx += xStep) {
          ctx.beginPath();
          ctx.arc(cx, cy, r, 0, Math.PI * 2);
          ctx.stroke();
        }
      }

      ctx.restore();
    }

    function render() {
      const wPx = Math.max(1, parseMeasureToPxOrDefault(outWInEl.value, 8.5));
      const hPx = Math.max(1, parseMeasureToPxOrDefault(outHInEl.value, 11));
      const tilePx = Math.max(1, parseMeasureToPxOrDefault(imgInEl.value, 1));
      const gapPx = Math.max(0, parseMeasureToPxOrDefault(gapInEl.value, 0));

      canvas.width = wPx;
      canvas.height = hPx;

      // White background (important for JPG/PDF)
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.fillStyle = "#fff";
      ctx.fillRect(0, 0, wPx, hPx);
      ctx.restore();

      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";

      let tileMeta = null;
      if (originalBitmap && originalMeta) {
        tileMeta = drawCheckerboardTiles(wPx, hPx, tilePx, gapPx);
      }

      if (hexToggleEl.checked) {
        const diaPx = Math.max(1, parseMeasureToPxOrDefault(circleDiaInEl.value, 6.25));
        drawHexCircleOverlay(wPx, hPx, diaPx);
      }

      const wIn = parseMeasureToInchesForInfo(outWInEl.value, 8.5);
      const hIn = parseMeasureToInchesForInfo(outHInEl.value, 11);
      const tileIn = parseMeasureToInchesForInfo(imgInEl.value, 1);
      const gapInches = parseMeasureToInchesForInfo(gapInEl.value, 0);

      const parts = [];
      parts.push(`Canvas: ${wPx}×${hPx}px (${wIn.toFixed(2)}×${hIn.toFixed(2)} in @ ${DPI} DPI).`);
      parts.push(`Tile: ${tilePx}px (${tileIn.toFixed(2)}"). Gap: ${gapPx}px (${gapInches.toFixed(2)}").`);

      if (originalMeta) {
        parts.push(`Source: ${originalMeta.w}×${originalMeta.h}px (scaled from original each draw).`);
      } else {
        parts.push(`Upload an image to see tiles.`);
      }

      if (tileMeta) parts.push(`Grid approx: ${tileMeta.cols}×${tileMeta.rows}. Step: ${tileMeta.stepPx}px.`);

      if (hexToggleEl.checked) {
        const diaIn = parseMeasureToInchesForInfo(circleDiaInEl.value, 6.25);
        const diaPx = parseMeasureToPxOrDefault(circleDiaInEl.value, 6.25);
        parts.push(`Hex overlay ON: diameter ${diaPx}px (${diaIn.toFixed(2)}").`);
      } else {
        parts.push(`Hex overlay OFF.`);
      }

      renderInfo.textContent = parts.join(" ");
    }

    function downloadBlob(blob, filename) {
      const a = document.createElement("a");
      const url = URL.createObjectURL(blob);
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function exportNow() 
	{
		  // Always render before export to make sure the content is updated
		  render();
		  			// Convert canvas to data URL and add it to the PDF at the correct size
			const dataUrl = canvas.toDataURL("image/png");

		  const base = `${originalFileBaseName} Random Pattern`;
		  const fmt = formatEl.value;

		  // Retrieve width and height in inches from the global variables
		  const widthInches = parseFloat(outWInEl.value);  // Width in inches from outWInEl
		  const heightInches = parseFloat(outHInEl.value);  // Height in inches from outHInEl

		  // Check if the input values are valid numbers
		  if (isNaN(widthInches) || isNaN(heightInches)) {
			console.error("Invalid width or height values");
			return;
		  }

		  // Calculate pixel dimensions based on DPI
		  const widthPx = Math.round(widthInches * DPI);  // Width in pixels based on DPI
		  const heightPx = Math.round(heightInches * DPI);  // Height in pixels based on DPI

		  // Set the canvas internal resolution (in pixels)
		  canvas.width = widthPx;
		  canvas.height = heightPx;

		  // Set the canvas display size (this is what the user sees, doesn't affect the DPI)
		  canvas.style.width = `${widthInches}in`;
		  canvas.style.height = `${heightInches}in`;

		  // Scale the drawing context to ensure the canvas drawing respects the DPI
		  const ctx = canvas.getContext('2d');
		  ctx.scale(DPI, DPI);

		  // Now export based on the selected format (PNG, JPG, PDF)

		  if (fmt === "png") {
			// Export as PNG with the desired DPI (based on the canvas resolution)
			canvas.toBlob((blob) => 
			{
				 changeDpiBlob(blob, DPI).then(function(blob)
					{
						downloadBlob(blob, `${base}.png`);
					})
			}, "image/png");
			return;
		  }

		  if (fmt === "jpg") {
			// Export as JPG with the desired DPI (based on the canvas resolution)
			canvas.toBlob((blob) => 
			{
				 changeDpiBlob(blob, DPI).then(function(blob)
					{
						downloadBlob(blob, `${base}.jpg`);
					})
			}, "image/jpeg", 0.95);  // Adjust quality if needed
			return;
		  }

		  if (fmt === "pdf") {
			const { jsPDF } = window.jspdf;

			// Calculate page size in points (72 points per inch)
			const wPt = widthInches * 72 * DPI;  // Width in points, scaled by DPI
			const hPt = heightInches * 72 * DPI;  // Height in points, scaled by DPI

			// Create PDF with the correct dimensions
			const pdf = new jsPDF({
			  orientation: (wPt >= hPt) ? "landscape" : "portrait",
			  unit: "pt",
			  format: [wPt, hPt]
			});
			pdf.addImage(ExPPI, "PNG", 0, 0, wPt, hPt);
			pdf.save(`${base}.pdf`);
		  }
		}
		exportBtn.addEventListener('click', exportNow);
		renderBtn.addEventListener('click', render);
  </script>
</body>
</html>
