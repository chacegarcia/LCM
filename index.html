<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HP Artwork Generator (Vector Pattern PDF)</title>
  <link rel="icon" href="favicon.ico" type="image/x-icon"/>
  <style>
    :root { --gap: 16px; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; }
    .wrap { display: grid; grid-template-columns: 360px 1fr; gap: var(--gap); padding: var(--gap); align-items: start; }
    .panel { border: 1px solid #e6e6e6; border-radius: 12px; padding: 14px; position: sticky; top: 12px; background: #fff; }
    .field { margin-bottom: 12px; }
    label { display: block; font-size: 12px; opacity: 0.85; margin-bottom: 6px; }
    input[type="text"], button {
      font-size: 14px; padding: 9px 10px; width: 100%;
      border: 1px solid #d9d9d9; border-radius: 10px; background: #fff;
      box-sizing: border-box;
    }
    input[type="checkbox"] { transform: scale(1.1); }
    button { cursor: pointer; }
    .btnRow { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; }
    .meta { font-size: 12px; opacity: 0.8; line-height: 1.35; margin-top: 8px; }
    .stage { border: 1px solid #e6e6e6; border-radius: 12px; padding: 14px; background: #fff; overflow: auto; }
    canvas { border: 1px solid #cfcfcf; display: block; max-width: 100%; height: auto; touch-action: none; }
    .hint { font-size: 12px; opacity: 0.75; margin-bottom: 10px; }
    .row2 { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .toggleLine { display: flex; gap: 10px; align-items: center; padding: 8px 10px; border: 1px solid #d9d9d9; border-radius: 10px; }
    .toggleLine span { font-size: 14px; }
    .pill { display:inline-block; font-size:12px; padding:2px 8px; border:1px solid #d9d9d9; border-radius:999px; margin-left:6px; opacity:.85; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <div class="field">
        <label>Upload image (any size)</label>
        <input id="fileInput" type="file" accept="image/*" />
        <div class="meta" id="imgInfo">No image loaded.</div>
      </div>

      <div class="field">
        <label>Tile size (inches)</label>
        <input id="imgIn" type="text" value='1"' />
      </div>

      <div class="field">
        <label>Gap around each cell (inches)</label>
        <input id="gapIn" type="text" value='0"' />
      </div>

      <div class="row2">
        <div class="field">
          <label>Final width (inches)</label>
          <input id="outWIn" type="text" value='8.5"' />
        </div>
        <div class="field">
          <label>Final height (inches)</label>
          <input id="outHIn" type="text" value='11"' />
        </div>
      </div>

      <div class="field">
        <label>Hex-packed circle overlay <span class="pill">Vector</span></label>
        <div class="toggleLine">
          <input id="hexToggle" type="checkbox" />
          <span>Show hex-packed circles</span>
        </div>
        <div style="height:10px;"></div>
        <label>Circle diameter (inches)</label>
        <input id="circleDiaIn" type="text" value='6.25"' />
      </div>

      <div class="field">
        <label>Export <span class="pill">PDF only</span></label>
        <div class="toggleLine">
          <input id="vectorToggle" type="checkbox" checked />
          <span>Vector outline tiling (auto-tuned)</span>
        </div>
        <div class="meta">
          Auto-tuned for efficient quality/file size based on output + tile size. <br/>
          If the pattern would require too many vector stamps, it falls back to a small raster-tiled PDF.
        </div>
      </div>

      <div class="btnRow">
        <button id="renderBtn">Reload Preview</button>
        <button id="exportBtn">Export PDF</button>
      </div>

      <div class="meta" id="renderInfo">
        Tip: Drag preview to pan. Pinch/scroll to zoom. Export is PDF-only.
      </div>
    </div>

    <div class="stage">
      <div class="hint">
        Preview is a <b>6&quot;×6&quot; window</b> into the full output. Drag to pan. Pinch/scroll to zoom.
      </div>
      <canvas id="canvas"></canvas>
    </div>
  </div>

  <!-- jsPDF -->
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <!-- svg2pdf plugin for jsPDF (enables pdf.svg(...)) -->
  <script src="https://cdn.jsdelivr.net/npm/svg2pdf.js@2.0.0/dist/svg2pdf.umd.min.js"></script>
  <!-- ImageTracer (raster → SVG) -->
  <script src="https://cdn.jsdelivr.net/npm/imagetracerjs@1.2.6/imagetracer_v1.2.6.js"></script>

  <script>
    // ---------------- PREVIEW SETTINGS ----------------
    const DPI = 200;               // only used for parsing px->in
    const PREVIEW_IN = 6;          // preview window is 6" x 6"
    const PREVIEW_CSS_PX = 420;
    const PREVIEW_PPI = 200;       // preview render PPI (safe on mobile)

    // ---------------- BAKED EXPORT POLICY ----------------
    // iOS-safe vector stamp budget (bigger than this gets slow/crashy)
    const MAX_VECTOR_STAMPS = 6000;

    // Trace size bounds (iOS-safe)
    const MAX_TRACE_DIM_PX_CAP = 1800;
    const MIN_TRACE_DIM_PX = 900;

    // Trace tuning (for transparent PNG logos)
    const TRACE_DETAIL = 1.1;     // stability > detail (prevents "glitchy")
    const TRACE_COLORS = 6;        // IMPORTANT: alpha-mask trace is 2-color

    // Raster fallback tuning (baked)
    const RASTER_TILE_IN = 6;
    const RASTER_PPI_MIN = 96;
    const RASTER_PPI_MAX = 220;
    const RASTER_JPEG_QUALITY = 0.82;

    // ------------------------------------------------
    const fileInput = document.getElementById('fileInput');
    const imgInEl = document.getElementById('imgIn');
    const gapInEl = document.getElementById('gapIn');
    const outWInEl = document.getElementById('outWIn');
    const outHInEl = document.getElementById('outHIn');
    const hexToggleEl = document.getElementById('hexToggle');
    const circleDiaInEl = document.getElementById('circleDiaIn');
    const vectorToggleEl = document.getElementById('vectorToggle');
    const renderBtn = document.getElementById('renderBtn');
    const exportBtn = document.getElementById('exportBtn');

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const imgInfo = document.getElementById('imgInfo');
    const renderInfo = document.getElementById('renderInfo');

    let originalBitmap = null;
    let originalMeta = null;
    let originalFileBaseName = "Artwork";

    // Preview camera (in OUTPUT inches)
    const previewCam = { xIn: 0, yIn: 0, zoom: 1 };

    // ---------- util ----------
    function tryParseToInches(text) {
      const raw = (text ?? "").toString().trim().toLowerCase();
      if (!raw) return null;
      const cleaned = raw.replace(/\s+/g, "");
      const pxMatch = cleaned.match(/^([0-9]*\.?[0-9]+)px$/);
      if (pxMatch) {
        const px = Number(pxMatch[1]);
        return Number.isFinite(px) ? (px / DPI) : null;
      }
      const inchMatch = cleaned.match(/^([0-9]*\.?[0-9]+)(in|inch|inches|")?$/);
      if (inchMatch) {
        const inches = Number(inchMatch[1]);
        return Number.isFinite(inches) ? inches : null;
      }
      return null;
    }
    function parseInchesOrDefault(text, defIn) {
      const v = tryParseToInches(text);
      return (v === null) ? defIn : v;
    }
    function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }

    function clampPreviewCam(outWIn, outHIn) {
      const viewWIn = PREVIEW_IN / previewCam.zoom;
      const viewHIn = PREVIEW_IN / previewCam.zoom;
      const maxX = Math.max(0, outWIn - viewWIn);
      const maxY = Math.max(0, outHIn - viewHIn);
      previewCam.xIn = clamp(previewCam.xIn, 0, maxX);
      previewCam.yIn = clamp(previewCam.yIn, 0, maxY);
    }

    function setupPreviewCanvas() {
      canvas.style.width = PREVIEW_CSS_PX + "px";
      canvas.style.height = PREVIEW_CSS_PX + "px";
      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.round(PREVIEW_CSS_PX * dpr);
      canvas.height = Math.round(PREVIEW_CSS_PX * dpr);
      ctx.setTransform(1,0,0,1,0,0);
    }

    async function loadAndCacheOriginal(file) {
      originalFileBaseName = (file.name || "Artwork").replace(/\.[^/.]+$/, "");

      if (originalBitmap && typeof originalBitmap.close === "function") {
        try { originalBitmap.close(); } catch {}
      }
      originalBitmap = null;
      originalMeta = null;

      const url = URL.createObjectURL(file);
      try {
        if ("createImageBitmap" in window) {
          const blob = await fetch(url).then(r => r.blob());
          const bmp = await createImageBitmap(blob);
          originalBitmap = bmp;
          originalMeta = { w: bmp.width, h: bmp.height };
          imgInfo.textContent = `Loaded: ${bmp.width}×${bmp.height}px (cached as ImageBitmap).`;
          return;
        }
        await new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => {
            originalBitmap = img;
            originalMeta = { w: img.naturalWidth || img.width, h: img.naturalHeight || img.height };
            imgInfo.textContent = `Loaded: ${originalMeta.w}×${originalMeta.h}px (cached as Image).`;
            resolve();
          };
          img.onerror = reject;
          img.src = url;
        });
      } finally {
        URL.revokeObjectURL(url);
      }
    }

    fileInput.addEventListener("change", async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      imgInfo.textContent = "Loading...";
      try {
        await loadAndCacheOriginal(file);
        previewCam.xIn = 0; previewCam.yIn = 0; previewCam.zoom = 1;
        renderPreview();
      } catch (err) {
        console.error(err);
        originalBitmap = null; originalMeta = null;
        imgInfo.textContent = "Failed to load image.";
      }
    });

    // ---------- drawing (preview only) ----------
    function drawBoxedTileAtIn(targetCtx, pxPerIn, xIn, yIn, tileIn) {
      if (!originalBitmap || !originalMeta) return;

      const srcW = originalMeta.w;
      const srcH = originalMeta.h;
      const tilePx = tileIn * pxPerIn;

      const scale = Math.min(tilePx / srcW, tilePx / srcH); // contain
      const drawWIn = (srcW * scale) / pxPerIn;
      const drawHIn = (srcH * scale) / pxPerIn;

      const dx = xIn + (tileIn - drawWIn) / 2;
      const dy = yIn + (tileIn - drawHIn) / 2;

      targetCtx.drawImage(originalBitmap, dx, dy, drawWIn, drawHIn);
    }

    function renderArtworkViewport(targetCtx, pxPerIn, cfg) {
      const { tileInches, gapIn, hexOn, circleDiaIn, camXIn, camYIn, viewWIn, viewHIn } = cfg;

      const wPx = Math.max(1, Math.round(viewWIn * pxPerIn));
      const hPx = Math.max(1, Math.round(viewHIn * pxPerIn));

      targetCtx.setTransform(1,0,0,1,0,0);
      targetCtx.clearRect(0,0,wPx,hPx);
      targetCtx.fillStyle = "#fff";
      targetCtx.fillRect(0,0,wPx,hPx);

      targetCtx.setTransform(pxPerIn, 0, 0, pxPerIn, 0, 0);
      targetCtx.imageSmoothingEnabled = true;
      targetCtx.imageSmoothingQuality = "high";

      const stepIn = (tileInches + gapIn) / 1.5;

      const startC = Math.floor(camXIn / stepIn) - 2;
      const startR = Math.floor(camYIn / stepIn) - 2;
      const endC   = Math.ceil((camXIn + viewWIn) / stepIn) + 2;
      const endR   = Math.ceil((camYIn + viewHIn) / stepIn) + 2;

      let approxCols = Math.max(0, endC - startC);
      let approxRows = Math.max(0, endR - startR);

      for (let r = startR; r < endR; r++) {
        for (let c = startC; c < endC; c++) {
          if (((r + c) % 2) !== 0) continue;

          const xFull = c * stepIn;
          const yFull = r * stepIn;

          const x = xFull - camXIn;
          const y = yFull - camYIn;

          if (x > viewWIn || y > viewHIn || x + tileInches < 0 || y + tileInches < 0) continue;
          drawBoxedTileAtIn(targetCtx, pxPerIn, x, y, tileInches);
        }
      }

      if (hexOn) {
        const dia = circleDiaIn;
        const rr = dia / 2;
        const xStep = dia;
        const yStep = dia * Math.sqrt(3) / 2;

        targetCtx.save();
        targetCtx.lineWidth = Math.max(1/pxPerIn, 0.01);
        targetCtx.globalAlpha = 0.65;

        let row = Math.floor((camYIn - rr) / yStep);
        for (let cyFull = row * yStep; cyFull <= camYIn + viewHIn + rr; cyFull += yStep, row++) {
          const xOffset = (row % 2 === 0) ? 0 : xStep / 2;
          let col = Math.floor((camXIn - rr - xOffset) / xStep);

          for (let cxFull = col * xStep + xOffset; cxFull <= camXIn + viewWIn + rr; cxFull += xStep) {
            const cx = cxFull - camXIn;
            const cy = cyFull - camYIn;
            targetCtx.beginPath();
            targetCtx.arc(cx, cy, rr, 0, Math.PI * 2);
            targetCtx.stroke();
          }
        }
        targetCtx.restore();
      }

      return { approxCols, approxRows, stepIn };
    }

    function estimateVectorStamps(outWIn, outHIn, tileInches, gapIn) {
      const stepIn = (tileInches + gapIn) / 1.5;
      const cols = Math.ceil(outWIn / stepIn) + 1;
      const rows = Math.ceil(outHIn / stepIn) + 1;
      return Math.ceil((cols * rows) / 2);
    }

    function renderPreview() {
      const outWIn = parseInchesOrDefault(outWInEl.value, 8.5);
      const outHIn = parseInchesOrDefault(outHInEl.value, 11);
      const tileInches = parseInchesOrDefault(imgInEl.value, 1);
      const gapIn  = Math.max(0, parseInchesOrDefault(gapInEl.value, 0));
      const hexOn  = !!hexToggleEl.checked;
      const circleDiaIn = parseInchesOrDefault(circleDiaInEl.value, 6.25);

      clampPreviewCam(outWIn, outHIn);
      setupPreviewCanvas();

      const viewWIn = PREVIEW_IN / previewCam.zoom;
      const viewHIn = PREVIEW_IN / previewCam.zoom;

      const off = document.createElement("canvas");
      off.width  = Math.max(1, Math.round(viewWIn * PREVIEW_PPI));
      off.height = Math.max(1, Math.round(viewHIn * PREVIEW_PPI));
      const octx = off.getContext("2d");

      const meta = renderArtworkViewport(octx, PREVIEW_PPI, {
        tileInches, gapIn, hexOn, circleDiaIn,
        camXIn: previewCam.xIn, camYIn: previewCam.yIn,
        viewWIn, viewHIn
      });

      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(off, 0, 0, canvas.width, canvas.height);

      const est = estimateVectorStamps(outWIn, outHIn, tileInches, gapIn);
      const parts = [];
      parts.push(`Preview: ${viewWIn.toFixed(2)}"×${viewHIn.toFixed(2)}" (zoom ${previewCam.zoom.toFixed(2)}×).`);
      parts.push(`Pan: x=${previewCam.xIn.toFixed(2)}", y=${previewCam.yIn.toFixed(2)}".`);
      parts.push(`Output: ${outWIn.toFixed(2)}×${outHIn.toFixed(2)} in.`);
      if (originalMeta) parts.push(`Source: ${originalMeta.w}×${originalMeta.h}px.`);
      parts.push(`Tile: ${tileInches.toFixed(2)}". Gap: ${gapIn.toFixed(2)}".`);
      parts.push(`Est. vector stamps: ~${est} (limit ${MAX_VECTOR_STAMPS}).`);
      parts.push(`Vector mode: ${vectorToggleEl.checked ? "ON" : "OFF"} (PDF only).`);
      parts.push(`Viewport tiles checked ~ ${meta.approxCols}×${meta.approxRows}.`);
      renderInfo.textContent = parts.join(" ");
    }

    // ---------- PDF delivery (download-first, no new tab) ----------
    async function deliverPdfBlob(blob, filename) {
      // Try a true download first
      try {
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        a.rel = "noopener";
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 60_000);
      } catch {}

      // Reliable iOS path: share sheet (no new tab)
      if (navigator.share) {
        try {
          const file = new File([blob], filename, { type: "application/pdf" });
          if (!navigator.canShare || navigator.canShare({ files: [file] })) {
            await navigator.share({ files: [file], title: filename });
            return true;
          }
        } catch {}
      }

      renderInfo.textContent =
        "If you didn't get a download prompt: iOS may block direct PDF downloads. Use the Share sheet to Save to Files.";
      return false;
    }

    // ---------- VECTOR: trace ONCE to an SVG STAMP (fixed for transparent PNGs) ----------
    function computeTraceMaxDimPx(tileInches) {
      // Aim ~350 px per inch of tile (then clamp)
      const target = Math.round(tileInches * 350);
      return clamp(target, MIN_TRACE_DIM_PX, MAX_TRACE_DIM_PX_CAP);
    }

    async function traceToSvgStamp(traceMaxDimPx, colors, detail) {
  if (!originalBitmap || !originalMeta) throw new Error("No image loaded.");

  const srcW = originalMeta.w;
  const srcH = originalMeta.h;

  const scaleDown = Math.max(srcW / traceMaxDimPx, srcH / traceMaxDimPx, 1);
  const tW = Math.max(1, Math.round(srcW / scaleDown));
  const tH = Math.max(1, Math.round(srcH / scaleDown));

  const tcan = document.createElement("canvas");
  tcan.width = tW;
  tcan.height = tH;
  const tctx = tcan.getContext("2d", { willReadFrequently: true });

  // Chroma-key background so transparent PNG becomes a removable solid
  const KEY = { r: 255, g: 0, b: 255 };
  tctx.fillStyle = `rgb(${KEY.r},${KEY.g},${KEY.b})`;
  tctx.fillRect(0, 0, tW, tH);

  tctx.imageSmoothingEnabled = true;
  tctx.imageSmoothingQuality = "high";
  tctx.drawImage(originalBitmap, 0, 0, tW, tH);

  // IMPORTANT: flatten semi-transparent edge pixels to reduce "glitchy" speckle paths
  // - fully transparent => key color
  // - semi/opaque => force alpha 255 (keeps RGB, removes fringe transparency noise)
  const img = tctx.getImageData(0, 0, tW, tH);
  const d = img.data;
  const TRANSPARENT_A = 8; // <= this treated as transparent

  for (let i = 0; i < d.length; i += 4) {
    const a = d[i + 3];
    if (a <= TRANSPARENT_A) {
      d[i] = KEY.r; d[i + 1] = KEY.g; d[i + 2] = KEY.b; d[i + 3] = 255;
    } else {
      d[i + 3] = 255;
    }
  }
  tctx.putImageData(img, 0, 0);

  const options = {
    numberofcolors: clamp(Math.round(colors), 2, 32),
    colorsampling: 2,        // better for logos/flat art
    colorquantcycles: 3,     // helps stabilize palette
    scale: 1,
    pathomit: 10,            // ignores objects under set value in pixels HQ(1) - LQ(20)
    ltres: 1 / clamp(detail, 0.6, 2.5),
    qtres: 1 / clamp(detail, 0.6, 2.5),
    rightangleenhance: true
  };

  let svgStr = ImageTracer.imagedataToSVG(
    tctx.getImageData(0, 0, tW, tH),
    options
  );

  // Strip chroma-key background shapes from the SVG
  svgStr = svgStr
    .replace(/<[^>]+fill="rgb\(\s*255\s*,\s*0\s*,\s*255\s*\)"[^>]*>.*?<\/[^>]+>\s*/gsi, "")
    .replace(/<[^>]+fill="rgb\(\s*255\s*,\s*0\s*,\s*255\s*\)"[^>]*\/>\s*/gsi, "")
    .replace(/<[^>]+fill="#ff00ff"[^>]*>.*?<\/[^>]+>\s*/gsi, "")
    .replace(/<[^>]+fill="#ff00ff"[^>]*\/>\s*/gsi, "");

  const holder = document.createElement("div");
  holder.style.position = "fixed";
  holder.style.left = "-99999px";
  holder.style.top = "-99999px";
  holder.innerHTML = svgStr.trim();
  document.body.appendChild(holder);

  const svgEl = holder.querySelector("svg");
  if (!svgEl) {
    document.body.removeChild(holder);
    throw new Error("Trace did not produce an SVG element.");
  }

  // Keep stamp boxed in the tile region
  svgEl.setAttribute("preserveAspectRatio", "xMidYMid meet");
  svgEl.setAttribute("viewBox", `0 0 ${tW} ${tH}`);

  // DO NOT recolor fills (this keeps multi-color!)
  svgEl.remove();
  document.body.removeChild(holder);
  return svgEl;
}
    async function tileSvgPatternToPdf(pdf, svgStamp, outWIn, outHIn, tileInches, gapIn) {
      const tilePt = tileInches * 72;
      const stepPt = ((tileInches + gapIn) / 1.5) * 72;

      const pageWPt = outWIn * 72;
      const pageHPt = outHIn * 72;

      const cols = Math.ceil(pageWPt / stepPt) + 1;
      const rows = Math.ceil(pageHPt / stepPt) + 1;

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          if (((r + c) % 2) !== 0) continue;

          const xPt = c * stepPt;
          const yPt = r * stepPt;
          if (xPt > pageWPt || yPt > pageHPt) continue;

          await pdf.svg(svgStamp, { x: xPt, y: yPt, width: tilePt, height: tilePt });
        }
      }
    }

    // ---------- Vector hex overlay (PDF) ----------
    function drawHexOverlayPdf(pdf, outWIn, outHIn, diaIn) {
      const rIn = diaIn / 2;
      const xStep = diaIn;
      const yStep = diaIn * Math.sqrt(3) / 2;
      pdf.setLineWidth(Math.max(0.5, 0.01 * 72));

      let row = 0;
      for (let cy = -rIn; cy <= outHIn + rIn; cy += yStep, row++) {
        const xOffset = (row % 2 === 0) ? 0 : xStep / 2;
        for (let cx = -rIn + xOffset; cx <= outWIn + rIn; cx += xStep) {
          pdf.circle(cx * 72, cy * 72, rIn * 72, "S");
        }
      }
    }

    // ---------- RASTER fallback: auto-efficient PPI ----------
    function computeEfficientRasterPPI(outWIn, outHIn) {
      if (!originalMeta) return RASTER_PPI_MAX;
      const nativeW = originalMeta.w / outWIn;
      const nativeH = originalMeta.h / outHIn;
      const native = Math.min(nativeW, nativeH);
      return clamp(Math.round(native * 2), RASTER_PPI_MIN, RASTER_PPI_MAX);
    }

    function renderArtworkTileRaster(targetCtx, pxPerIn, cfg) {
      const { tileInches, gapIn, hexOn, circleDiaIn, x0In, y0In, wIn, hIn } = cfg;

      const wPx = Math.max(1, Math.round(wIn * pxPerIn));
      const hPx = Math.max(1, Math.round(hIn * pxPerIn));

      targetCtx.setTransform(1,0,0,1,0,0);
      targetCtx.clearRect(0,0,wPx,hPx);
      targetCtx.fillStyle = "#fff";
      targetCtx.fillRect(0,0,wPx,hPx);

      targetCtx.setTransform(pxPerIn,0,0,pxPerIn,0,0);
      targetCtx.imageSmoothingEnabled = true;
      targetCtx.imageSmoothingQuality = "high";

      const stepIn = (tileInches + gapIn) / 1.5;

      const startC = Math.floor(x0In / stepIn) - 2;
      const startR = Math.floor(y0In / stepIn) - 2;
      const endC   = Math.ceil((x0In + wIn) / stepIn) + 2;
      const endR   = Math.ceil((y0In + hIn) / stepIn) + 2;

      for (let r = startR; r < endR; r++) {
        for (let c = startC; c < endC; c++) {
          if (((r + c) % 2) !== 0) continue;

          const xFull = c * stepIn;
          const yFull = r * stepIn;

          const x = xFull - x0In;
          const y = yFull - y0In;

          if (x > wIn || y > hIn || x + tileInches < 0 || y + tileInches < 0) continue;

          drawBoxedTileAtIn(targetCtx, pxPerIn, x, y, tileInches);
        }
      }

      if (hexOn) {
        const dia = circleDiaIn;
        const rr = dia / 2;
        const xStep = dia;
        const yStep = dia * Math.sqrt(3) / 2;

        targetCtx.save();
        targetCtx.lineWidth = Math.max(1/pxPerIn, 0.01);
        targetCtx.globalAlpha = 0.65;

        let row = Math.floor((y0In - rr) / yStep);
        for (let cyFull = row * yStep; cyFull <= y0In + hIn + rr; cyFull += yStep, row++) {
          const xOffset = (row % 2 === 0) ? 0 : xStep / 2;
          let col = Math.floor((x0In - rr - xOffset) / xStep);

          for (let cxFull = col * xStep + xOffset; cxFull <= x0In + wIn + rr; cxFull += xStep) {
            const cx = cxFull - x0In;
            const cy = cyFull - y0In;
            targetCtx.beginPath();
            targetCtx.arc(cx, cy, rr, 0, Math.PI * 2);
            targetCtx.stroke();
          }
        }
        targetCtx.restore();
      }
    }

    // ---------- EXPORT ----------
    async function exportNow() {
      if (!originalBitmap || !originalMeta) {
        renderInfo.textContent = "Upload an image first.";
        return;
      }

      const outWIn = parseInchesOrDefault(outWInEl.value, 8.5);
      const outHIn = parseInchesOrDefault(outHInEl.value, 11);
      const tileInches = parseInchesOrDefault(imgInEl.value, 1);
      const gapIn  = Math.max(0, parseInchesOrDefault(gapInEl.value, 0));
      const hexOn  = !!hexToggleEl.checked;
      const circleDiaIn = parseInchesOrDefault(circleDiaInEl.value, 6.25);

      const base = `${originalFileBaseName} Random Pattern`;
      const filename = `${base}.pdf`;

      const { jsPDF } = window.jspdf || {};
      if (!jsPDF) {
        renderInfo.textContent = "PDF export failed: jsPDF not loaded.";
        return;
      }

      const wPt = outWIn * 72;
      const hPt = outHIn * 72;

      const pdf = new jsPDF({
        orientation: (wPt >= hPt) ? "landscape" : "portrait",
        unit: "pt",
        format: [wPt, hPt],
        compress: true
      });

      const estStamps = estimateVectorStamps(outWIn, outHIn, tileInches, gapIn);

      // --- VECTOR PATH ---
      if (vectorToggleEl.checked && estStamps <= MAX_VECTOR_STAMPS) {
        try {
          const traceMaxDim = computeTraceMaxDimPx(tileInches);
          renderInfo.textContent = `Vector: tracing once (max ${traceMaxDim}px)…`;

          const svgStamp = await traceToSvgStamp(traceMaxDim, TRACE_COLORS, TRACE_DETAIL);

          renderInfo.textContent = `Vector: tiling ${estStamps} stamps…`;
          await tileSvgPatternToPdf(pdf, svgStamp, outWIn, outHIn, tileInches, gapIn);

          if (hexOn) drawHexOverlayPdf(pdf, outWIn, outHIn, circleDiaIn);

          renderInfo.textContent = "PDF built. Sending download…";
          const blob = pdf.output("blob");
          await deliverPdfBlob(blob, filename);
          return;
        } catch (err) {
          console.error(err);
          renderInfo.textContent = "Vector failed. Falling back to raster tiled PDF…";
        }
      } else if (vectorToggleEl.checked && estStamps > MAX_VECTOR_STAMPS) {
        renderInfo.textContent = `Vector would place ~${estStamps} stamps (limit ${MAX_VECTOR_STAMPS}). Falling back to raster…`;
      }

      // --- RASTER FALLBACK ---
      const rasterPPI = computeEfficientRasterPPI(outWIn, outHIn);
      const tileIn = RASTER_TILE_IN;

      const cols = Math.ceil(outWIn / tileIn);
      const rows = Math.ceil(outHIn / tileIn);

      const tileCanvas = document.createElement("canvas");
      let tctx = tileCanvas.getContext("2d");
      let count = 0;
      const total = cols * rows;

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const x0 = c * tileIn;
          const y0 = r * tileIn;
          const wIn = Math.min(tileIn, outWIn - x0);
          const hIn = Math.min(tileIn, outHIn - y0);

          const wPx = Math.max(1, Math.round(wIn * rasterPPI));
          const hPx = Math.max(1, Math.round(hIn * rasterPPI));

          if (tileCanvas.width !== wPx) tileCanvas.width = wPx;
          if (tileCanvas.height !== hPx) tileCanvas.height = hPx;
          tctx = tileCanvas.getContext("2d");

          renderArtworkTileRaster(tctx, rasterPPI, {
            tileInches, gapIn, hexOn, circleDiaIn,
            x0In: x0, y0In: y0, wIn, hIn
          });

          const dataUrl = tileCanvas.toDataURL("image/jpeg", RASTER_JPEG_QUALITY);
          pdf.addImage(dataUrl, "JPEG", x0 * 72, y0 * 72, wIn * 72, hIn * 72);

          count++;
          if (count % 8 === 0) renderInfo.textContent = `Raster PDF: ${count}/${total} tiles… (PPI ${rasterPPI})`;
        }
      }

      renderInfo.textContent = `Raster PDF built (PPI ${rasterPPI}). Sending download…`;
      const blob = pdf.output("blob");
      await deliverPdfBlob(blob, filename);
    }

    // ---------- pan/zoom preview ----------
    let isPanning = false;
    let panStart = null;

    canvas.addEventListener("pointerdown", (e) => {
      canvas.setPointerCapture(e.pointerId);
      isPanning = true;
      panStart = { x: e.clientX, y: e.clientY, camX: previewCam.xIn, camY: previewCam.yIn };
    });

    canvas.addEventListener("pointermove", (e) => {
      if (!isPanning || !panStart) return;

      const outWIn = parseInchesOrDefault(outWInEl.value, 8.5);
      const outHIn = parseInchesOrDefault(outHInEl.value, 11);

      const rect = canvas.getBoundingClientRect();
      const pxPerInCss = rect.width / PREVIEW_IN;

      const dxInPreview = (e.clientX - panStart.x) / pxPerInCss;
      const dyInPreview = (e.clientY - panStart.y) / pxPerInCss;

      const dxOut = dxInPreview / previewCam.zoom;
      const dyOut = dyInPreview / previewCam.zoom;

      previewCam.xIn = panStart.camX - dxOut;
      previewCam.yIn = panStart.camY - dyOut;

      clampPreviewCam(outWIn, outHIn);
      renderPreview();
    });

    function endPan() { isPanning = false; panStart = null; }
    canvas.addEventListener("pointerup", endPan);
    canvas.addEventListener("pointercancel", endPan);

    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const outWIn = parseInchesOrDefault(outWInEl.value, 8.5);
      const outHIn = parseInchesOrDefault(outHInEl.value, 11);

      const factor = (e.deltaY < 0) ? 1.12 : (1 / 1.12);
      previewCam.zoom = clamp(previewCam.zoom * factor, 1, 8);

      clampPreviewCam(outWIn, outHIn);
      renderPreview();
    }, { passive: false });

    // Mobile pinch zoom
    const activePointers = new Map();
    let pinchStart = null;
    function dist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }

    canvas.addEventListener("pointerdown", (e) => {
      activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
      if (activePointers.size === 2) {
        const pts = Array.from(activePointers.values());
        pinchStart = { d: dist(pts[0], pts[1]), zoom: previewCam.zoom };
      }
    });

    canvas.addEventListener("pointermove", (e) => {
      if (!activePointers.has(e.pointerId)) return;
      activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

      if (activePointers.size === 2 && pinchStart) {
        const outWIn = parseInchesOrDefault(outWInEl.value, 8.5);
        const outHIn = parseInchesOrDefault(outHInEl.value, 11);

        const pts = Array.from(activePointers.values());
        const dNow = dist(pts[0], pts[1]);
        if (pinchStart.d > 0) {
          const ratio = dNow / pinchStart.d;
          previewCam.zoom = clamp(pinchStart.zoom * ratio, 1, 8);
          clampPreviewCam(outWIn, outHIn);
          renderPreview();
        }
      }
    });

    canvas.addEventListener("pointerup", (e) => {
      activePointers.delete(e.pointerId);
      if (activePointers.size < 2) pinchStart = null;
    });
    canvas.addEventListener("pointercancel", (e) => {
      activePointers.delete(e.pointerId);
      if (activePointers.size < 2) pinchStart = null;
    });

    // ---------- buttons ----------
    renderBtn.addEventListener('click', renderPreview);
    exportBtn.addEventListener('click', exportNow);

    [imgInEl, gapInEl, outWInEl, outHInEl, circleDiaInEl].forEach(el => {
      el.addEventListener("change", renderPreview);
    });
    [hexToggleEl, vectorToggleEl].forEach(el => el.addEventListener("change", renderPreview));

    // Initial draw
    renderPreview();
  </script>
</body>
</html>
