<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HP Artwork Generator (PDF Only + Vector Outline Mode)</title>
  <style>
    :root { --gap: 16px; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; }
    .wrap { display: grid; grid-template-columns: 360px 1fr; gap: var(--gap); padding: var(--gap); align-items: start; }
    .panel {
      border: 1px solid #e6e6e6; border-radius: 12px; padding: 14px; position: sticky; top: 12px;
      background: #fff;
    }
    .field { margin-bottom: 12px; }
    label { display: block; font-size: 12px; opacity: 0.85; margin-bottom: 6px; }
    input[type="text"], select, button {
      font-size: 14px; padding: 9px 10px; width: 100%;
      border: 1px solid #d9d9d9; border-radius: 10px; background: #fff;
      box-sizing: border-box;
    }
    input[type="checkbox"] { transform: scale(1.1); }
    button { cursor: pointer; }
    .btnRow { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; }
    .meta { font-size: 12px; opacity: 0.8; line-height: 1.35; margin-top: 8px; }
    .stage {
      border: 1px solid #e6e6e6; border-radius: 12px; padding: 14px; background: #fff;
      overflow: auto;
    }
    canvas { border: 1px solid #cfcfcf; display: block; max-width: 100%; height: auto; touch-action: none; }
    .hint { font-size: 12px; opacity: 0.75; margin-bottom: 10px; }
    .row2 { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .toggleLine { display: flex; gap: 10px; align-items: center; padding: 8px 10px; border: 1px solid #d9d9d9; border-radius: 10px; }
    .toggleLine span { font-size: 14px; }
    .row3 { display:grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
  </style>
</head>
<body>
  <div class="wrap">
    <!-- LEFT COLUMN -->
    <div class="panel">
      <div class="field">
        <label>Upload image (any size)</label>
        <input id="fileInput" type="file" accept="image/*" />
        <div class="meta" id="imgInfo">No image loaded.</div>
      </div>

      <div class="field">
        <label>Tile size (inches)</label>
        <input id="imgIn" type="text" value='1"' />
      </div>

      <div class="field">
        <label>Gap around each cell (inches)</label>
        <input id="gapIn" type="text" value='0"' />
      </div>

      <div class="row2">
        <div class="field">
          <label>Final width (inches)</label>
          <input id="outWIn" type="text" value='8.5"' />
        </div>
        <div class="field">
          <label>Final height (inches)</label>
          <input id="outHIn" type="text" value='11"' />
        </div>
      </div>

      <div class="field">
        <label>Hex-packed circle overlay</label>
        <div class="toggleLine">
          <input id="hexToggle" type="checkbox" />
          <span>Show hex-packed circles</span>
        </div>
        <div style="height:10px;"></div>
        <label>Circle diameter (inches)</label>
        <input id="circleDiaIn" type="text" value='6.25"' />
      </div>

      <div class="field">
        <label>PDF Export Mode</label>

        <div class="toggleLine">
          <input id="vectorToggle" type="checkbox" />
          <span>Vector outline mode (trace to SVG → PDF)</span>
        </div>

        <div style="height:10px;"></div>

        <div class="row3">
          <div class="field">
            <label>Trace detail</label>
            <input id="traceDetail" type="text" value="1.0" />
          </div>
          <div class="field">
            <label>Colors</label>
            <input id="traceColors" type="text" value="8" />
          </div>
          <div class="field">
            <label>Trace PPI</label>
            <input id="tracePPI" type="text" value="180" />
          </div>
        </div>

        <div class="meta">
          Notes: Vector mode creates a true vector PDF (tiny + sharp), but depends on the raster quality.
          For logos/line-art it’s excellent. For photos it can get heavy.
        </div>
      </div>

      <div class="btnRow">
        <button id="renderBtn">Reload Preview</button>
        <button id="exportBtn">Export PDF</button>
      </div>

      <div class="meta" id="renderInfo">
        Tip: Drag preview to pan. Pinch/scroll to zoom. Export is PDF-only.
      </div>
    </div>

    <!-- RIGHT COLUMN -->
    <div class="stage">
      <div class="hint">
        Preview is a <b>6&quot;×6&quot; window</b> into the full output. Drag to pan. Pinch/scroll to zoom.
      </div>
      <canvas id="canvas"></canvas>
    </div>
  </div>

  <!-- jsPDF -->
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <!-- svg2pdf plugin for jsPDF (enables pdf.svg(...)) -->
  <script src="https://cdn.jsdelivr.net/npm/svg2pdf.js@2.0.0/dist/svg2pdf.umd.min.js"></script>
  <!-- ImageTracer (raster → SVG) -->
  <script src="https://cdn.jsdelivr.net/npm/imagetracerjs@1.2.6/imagetracer_v1.2.6.js"></script>

  <script>
    // ---------------- SETTINGS ----------------
    const DPI = 400;               // used for preview info only; PDF export is vector OR tiled raster fallback
    const PREVIEW_IN = 6;          // preview window is 6" x 6"
    const PREVIEW_CSS_PX = 420;
    const PREVIEW_PPI = 170;       // preview render PPI (safe on mobile)

    // Raster fallback PDF tiling (only used if vector mode is off OR vector tracing fails)
    const PDF_TILE_IN = 3;         // larger = fewer tiles, usually ok on iPad
    const PDF_RASTER_PPI_DEFAULT = 180; // raster-in-PDF resolution (keeps files sane)
    const PDF_JPEG_QUALITY = 0.82; // raster tiles compression (smaller PDF). Increase for crisper edges.
    // ------------------------------------------------

    const fileInput = document.getElementById('fileInput');
    const imgInEl = document.getElementById('imgIn');
    const gapInEl = document.getElementById('gapIn');
    const outWInEl = document.getElementById('outWIn');
    const outHInEl = document.getElementById('outHIn');

    const hexToggleEl = document.getElementById('hexToggle');
    const circleDiaInEl = document.getElementById('circleDiaIn');

    const vectorToggleEl = document.getElementById('vectorToggle');
    const traceDetailEl = document.getElementById('traceDetail');
    const traceColorsEl = document.getElementById('traceColors');
    const tracePPIEl = document.getElementById('tracePPI');

    const renderBtn = document.getElementById('renderBtn');
    const exportBtn = document.getElementById('exportBtn');

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    const imgInfo = document.getElementById('imgInfo');
    const renderInfo = document.getElementById('renderInfo');

    let originalBitmap = null;
    let originalMeta = null;
    let originalFileBaseName = "Artwork";

    // Preview camera (in OUTPUT inches)
    const previewCam = { xIn: 0, yIn: 0, zoom: 1 };

    // ---------- util ----------
    function tryParseToInches(text) {
      const raw = (text ?? "").toString().trim().toLowerCase();
      if (!raw) return null;
      const cleaned = raw.replace(/\s+/g, "");
      const pxMatch = cleaned.match(/^([0-9]*\.?[0-9]+)px$/);
      if (pxMatch) {
        const px = Number(pxMatch[1]);
        return Number.isFinite(px) ? (px / DPI) : null;
      }
      const inchMatch = cleaned.match(/^([0-9]*\.?[0-9]+)(in|inch|inches|")?$/);
      if (inchMatch) {
        const inches = Number(inchMatch[1]);
        return Number.isFinite(inches) ? inches : null;
      }
      return null;
    }
    function parseInchesOrDefault(text, defIn) {
      const v = tryParseToInches(text);
      return (v === null) ? defIn : v;
    }
    function parseNumberOrDefault(text, def) {
      const n = Number((text ?? "").toString().trim());
      return Number.isFinite(n) ? n : def;
    }
    function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }

    function clampPreviewCam(outWIn, outHIn) {
      const viewWIn = PREVIEW_IN / previewCam.zoom;
      const viewHIn = PREVIEW_IN / previewCam.zoom;
      const maxX = Math.max(0, outWIn - viewWIn);
      const maxY = Math.max(0, outHIn - viewHIn);
      previewCam.xIn = clamp(previewCam.xIn, 0, maxX);
      previewCam.yIn = clamp(previewCam.yIn, 0, maxY);
    }

    function setupPreviewCanvas() {
      canvas.style.width = PREVIEW_CSS_PX + "px";
      canvas.style.height = PREVIEW_CSS_PX + "px";
      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.round(PREVIEW_CSS_PX * dpr);
      canvas.height = Math.round(PREVIEW_CSS_PX * dpr);
      ctx.setTransform(1,0,0,1,0,0);
    }

    async function loadAndCacheOriginal(file) {
      originalFileBaseName = (file.name || "Artwork").replace(/\.[^/.]+$/, "");

      if (originalBitmap && typeof originalBitmap.close === "function") {
        try { originalBitmap.close(); } catch {}
      }
      originalBitmap = null;
      originalMeta = null;

      const url = URL.createObjectURL(file);
      try {
        if ("createImageBitmap" in window) {
          const blob = await fetch(url).then(r => r.blob());
          const bmp = await createImageBitmap(blob);
          originalBitmap = bmp;
          originalMeta = { w: bmp.width, h: bmp.height };
          imgInfo.textContent = `Loaded: ${bmp.width}×${bmp.height}px (cached as ImageBitmap).`;
          return;
        }
        await new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => {
            originalBitmap = img;
            originalMeta = { w: img.naturalWidth || img.width, h: img.naturalHeight || img.height };
            imgInfo.textContent = `Loaded: ${originalMeta.w}×${originalMeta.h}px (cached as Image).`;
            resolve();
          };
          img.onerror = reject;
          img.src = url;
        });
      } finally {
        URL.revokeObjectURL(url);
      }
    }

    fileInput.addEventListener("change", async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      imgInfo.textContent = "Loading...";
      try {
        await loadAndCacheOriginal(file);
        previewCam.xIn = 0; previewCam.yIn = 0; previewCam.zoom = 1;
        renderPreview();
      } catch (err) {
        console.error(err);
        originalBitmap = null; originalMeta = null;
        imgInfo.textContent = "Failed to load image.";
      }
    });

    // ---------- drawing ----------
    // BOXED (no stretch, no crop): contain/letterbox into the tile
    function drawBoxedTileAtIn(targetCtx, pxPerIn, xIn, yIn, tileIn) {
      if (!originalBitmap || !originalMeta) return;

      const srcW = originalMeta.w;
      const srcH = originalMeta.h;
      const tilePx = tileIn * pxPerIn;

      const scale = Math.min(tilePx / srcW, tilePx / srcH); // contain
      const drawWIn = (srcW * scale) / pxPerIn;
      const drawHIn = (srcH * scale) / pxPerIn;

      const dx = xIn + (tileIn - drawWIn) / 2;
      const dy = yIn + (tileIn - drawHIn) / 2;

      targetCtx.drawImage(originalBitmap, dx, dy, drawWIn, drawHIn);
    }

    function renderArtworkViewport(targetCtx, pxPerIn, cfg) {
      const { outWIn, outHIn, tileInches, gapIn, hexOn, circleDiaIn, camXIn, camYIn, viewWIn, viewHIn } = cfg;

      const wPx = Math.max(1, Math.round(viewWIn * pxPerIn));
      const hPx = Math.max(1, Math.round(viewHIn * pxPerIn));

      targetCtx.setTransform(1,0,0,1,0,0);
      targetCtx.clearRect(0,0,wPx,hPx);
      targetCtx.fillStyle = "#fff";
      targetCtx.fillRect(0,0,wPx,hPx);

      targetCtx.setTransform(pxPerIn, 0, 0, pxPerIn, 0, 0);
      targetCtx.imageSmoothingEnabled = true;
      targetCtx.imageSmoothingQuality = "high";

      const stepIn = (tileInches + gapIn) / 1.5;

      const startC = Math.floor(camXIn / stepIn) - 2;
      const startR = Math.floor(camYIn / stepIn) - 2;
      const endC   = Math.ceil((camXIn + viewWIn) / stepIn) + 2;
      const endR   = Math.ceil((camYIn + viewHIn) / stepIn) + 2;

      let approxCols = Math.max(0, endC - startC);
      let approxRows = Math.max(0, endR - startR);

      for (let r = startR; r < endR; r++) {
        for (let c = startC; c < endC; c++) {
          if (((r + c) % 2) !== 0) continue;

          const xFull = c * stepIn;
          const yFull = r * stepIn;

          const x = xFull - camXIn;
          const y = yFull - camYIn;

          if (x > viewWIn || y > viewHIn || x + tileInches < 0 || y + tileInches < 0) continue;

          drawBoxedTileAtIn(targetCtx, pxPerIn, x, y, tileInches);
        }
      }

      if (hexOn) {
        const dia = circleDiaIn;
        const rr = dia / 2;
        const xStep = dia;
        const yStep = dia * Math.sqrt(3) / 2;

        targetCtx.save();
        targetCtx.lineWidth = Math.max(1/pxPerIn, 0.01);
        targetCtx.globalAlpha = 0.65;

        let row = Math.floor((camYIn - rr) / yStep);
        for (let cyFull = row * yStep; cyFull <= camYIn + viewHIn + rr; cyFull += yStep, row++) {
          const xOffset = (row % 2 === 0) ? 0 : xStep / 2;
          let col = Math.floor((camXIn - rr - xOffset) / xStep);

          for (let cxFull = col * xStep + xOffset; cxFull <= camXIn + viewWIn + rr; cxFull += xStep) {
            const cx = cxFull - camXIn;
            const cy = cyFull - camYIn;

            targetCtx.beginPath();
            targetCtx.arc(cx, cy, rr, 0, Math.PI * 2);
            targetCtx.stroke();
          }
        }

        targetCtx.restore();
      }

      return { approxCols, approxRows, stepIn };
    }

    function renderPreview() {
      const outWIn = parseInchesOrDefault(outWInEl.value, 8.5);
      const outHIn = parseInchesOrDefault(outHInEl.value, 11);
      const tileInches = parseInchesOrDefault(imgInEl.value, 1);
      const gapIn  = Math.max(0, parseInchesOrDefault(gapInEl.value, 0));
      const hexOn  = !!hexToggleEl.checked;
      const circleDiaIn = parseInchesOrDefault(circleDiaInEl.value, 6.25);

      clampPreviewCam(outWIn, outHIn);
      setupPreviewCanvas();

      const viewWIn = PREVIEW_IN / previewCam.zoom;
      const viewHIn = PREVIEW_IN / previewCam.zoom;

      const off = document.createElement("canvas");
      off.width  = Math.max(1, Math.round(viewWIn * PREVIEW_PPI));
      off.height = Math.max(1, Math.round(viewHIn * PREVIEW_PPI));
      const octx = off.getContext("2d");

      const meta = renderArtworkViewport(octx, PREVIEW_PPI, {
        outWIn, outHIn, tileInches, gapIn, hexOn, circleDiaIn,
        camXIn: previewCam.xIn, camYIn: previewCam.yIn,
        viewWIn, viewHIn
      });

      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(off, 0, 0, canvas.width, canvas.height);

      const parts = [];
      parts.push(`Preview: ${viewWIn.toFixed(2)}"×${viewHIn.toFixed(2)}" (zoom ${previewCam.zoom.toFixed(2)}×).`);
      parts.push(`Pan: x=${previewCam.xIn.toFixed(2)}", y=${previewCam.yIn.toFixed(2)}".`);
      parts.push(`Output: ${outWIn.toFixed(2)}×${outHIn.toFixed(2)} in.`);
      if (originalMeta) parts.push(`Source: ${originalMeta.w}×${originalMeta.h}px.`);
      parts.push(`Tile: ${tileInches.toFixed(2)}". Gap: ${gapIn.toFixed(2)}".`);
      parts.push(`Vector mode: ${vectorToggleEl.checked ? "ON" : "OFF"} (PDF only).`);
      parts.push(`Viewport tiles checked ~ ${meta.approxCols}×${meta.approxRows}.`);
      renderInfo.textContent = parts.join(" ");
    }

    // ---------- iOS-friendly PDF delivery ----------
    async function shareBlobIfPossible(blob, filename) {
      if (!navigator.share) return false;
      try {
        const file = new File([blob], filename, { type: blob.type || "application/pdf" });
        if (navigator.canShare && !navigator.canShare({ files: [file] })) return false;
        await navigator.share({ files: [file], title: filename });
        return true;
      } catch { return false; }
    }
    function openBlobInNewTab(blob) {
      const url = URL.createObjectURL(blob);
      const w = window.open(url, "_blank");
      if (!w) window.location.href = url;
      setTimeout(() => URL.revokeObjectURL(url), 60_000);
    }

    // ---------- VECTOR TRACE: raster -> SVG -> PDF ----------
    // Build an SVG string from the uploaded image (using ImageTracer)
    async function traceToSvgString(tracePPI, colors, detail) {
      if (!originalBitmap || !originalMeta) throw new Error("No image loaded.");

      // Render to a trace canvas at a chosen PPI *based on intended output*.
      // We trace the SOURCE itself downscaled to a manageable size; this impacts detail and performance.
      // tracePPI is essentially "pixels per inch in the trace canvas" for the final PDF size.
      const outWIn = parseInchesOrDefault(outWInEl.value, 8.5);
      const outHIn = parseInchesOrDefault(outHInEl.value, 11);

      const maxW = Math.max(1, Math.round(outWIn * tracePPI));
      const maxH = Math.max(1, Math.round(outHIn * tracePPI));

      // To keep trace work bounded, clamp to a max dimension
      const MAX_TRACE_DIM = 2800; // good for iOS; increase on desktop
      let tW = maxW, tH = maxH;
      const scaleDown = Math.max(tW / MAX_TRACE_DIM, tH / MAX_TRACE_DIM, 1);
      tW = Math.round(tW / scaleDown);
      tH = Math.round(tH / scaleDown);

      const tcan = document.createElement("canvas");
      tcan.width = tW;
      tcan.height = tH;
      const tctx = tcan.getContext("2d");

      // White background so trace has a stable base (change if you need transparent)
      tctx.fillStyle = "#ffffff";
      tctx.fillRect(0, 0, tW, tH);

      // Draw the original image boxed into the trace canvas (same as your tile boxing idea)
      // Here we fill the whole page with the original image boxed (not tiling yet).
      const srcW = originalMeta.w, srcH = originalMeta.h;
      const scale = Math.min(tW / srcW, tH / srcH);
      const dW = Math.round(srcW * scale);
      const dH = Math.round(srcH * scale);
      const dx = Math.round((tW - dW) / 2);
      const dy = Math.round((tH - dH) / 2);

      tctx.imageSmoothingEnabled = true;
      tctx.imageSmoothingQuality = "high";
      tctx.drawImage(originalBitmap, dx, dy, dW, dH);

      // ImageTracer options:
      // - numberofcolors: controls palette size (smaller = simpler SVG)
      // - pathomit: omit small paths (helps reduce noise)
      // - ltres/qtres: line/curve fitting tolerances (higher = simpler)
      // - scale: keep 1 so SVG is in same pixel space as the trace canvas
      const options = {
        numberofcolors: clamp(Math.round(colors), 2, 32),
        scale: 1,
        pathomit: 10, // increase to simplify more
        ltres: 1 / clamp(detail, 0.5, 3), // detail up -> smaller tolerance
        qtres: 1 / clamp(detail, 0.5, 3),
        // "rightangleenhance" can help logos
        rightangleenhance: true
      };

      // Convert to SVG string
      const svgStr = ImageTracer.imagedataToSVG(
        tctx.getImageData(0, 0, tW, tH),
        options
      );

      // Wrap into an SVG that we can scale to inches in jsPDF
      // Ensure viewBox is correct; ImageTracer typically includes one, but we enforce.
      // We'll return as-is; jsPDF svg() will parse it.
      return svgStr;
    }

    // ---------- RASTER TILE PDF (fallback / optional) ----------
    function renderArtworkTileRaster(targetCtx, pxPerIn, cfg) {
      const {
        outWIn, outHIn,
        tileInches, gapIn,
        hexOn, circleDiaIn,
        x0In, y0In, wIn, hIn
      } = cfg;

      const wPx = Math.max(1, Math.round(wIn * pxPerIn));
      const hPx = Math.max(1, Math.round(hIn * pxPerIn));

      targetCtx.setTransform(1,0,0,1,0,0);
      targetCtx.clearRect(0,0,wPx,hPx);
      targetCtx.fillStyle = "#fff";
      targetCtx.fillRect(0,0,wPx,hPx);

      targetCtx.setTransform(pxPerIn,0,0,pxPerIn,0,0);
      targetCtx.imageSmoothingEnabled = true;
      targetCtx.imageSmoothingQuality = "high";

      const stepIn = (tileInches + gapIn) / 1.5;

      const startC = Math.floor(x0In / stepIn) - 2;
      const startR = Math.floor(y0In / stepIn) - 2;
      const endC   = Math.ceil((x0In + wIn) / stepIn) + 2;
      const endR   = Math.ceil((y0In + hIn) / stepIn) + 2;

      for (let r = startR; r < endR; r++) {
        for (let c = startC; c < endC; c++) {
          if (((r + c) % 2) !== 0) continue;

          const xFull = c * stepIn;
          const yFull = r * stepIn;

          const x = xFull - x0In;
          const y = yFull - y0In;

          if (x > wIn || y > hIn || x + tileInches < 0 || y + tileInches < 0) continue;

          drawBoxedTileAtIn(targetCtx, pxPerIn, x, y, tileInches);
        }
      }

      if (hexOn) {
        const dia = circleDiaIn;
        const rr = dia / 2;
        const xStep = dia;
        const yStep = dia * Math.sqrt(3) / 2;

        targetCtx.save();
        targetCtx.lineWidth = Math.max(1/pxPerIn, 0.01);
        targetCtx.globalAlpha = 0.65;

        let row = Math.floor((y0In - rr) / yStep);
        for (let cyFull = row * yStep; cyFull <= y0In + hIn + rr; cyFull += yStep, row++) {
          const xOffset = (row % 2 === 0) ? 0 : xStep / 2;
          let col = Math.floor((x0In - rr - xOffset) / xStep);

          for (let cxFull = col * xStep + xOffset; cxFull <= x0In + wIn + rr; cxFull += xStep) {
            const cx = cxFull - x0In;
            const cy = cyFull - y0In;
            targetCtx.beginPath();
            targetCtx.arc(cx, cy, rr, 0, Math.PI * 2);
            targetCtx.stroke();
          }
        }

        targetCtx.restore();
      }
    }

    // ---------- EXPORT PDF (vector mode or raster fallback) ----------
    async function exportNow() {
      const outWIn = parseInchesOrDefault(outWInEl.value, 8.5);
      const outHIn = parseInchesOrDefault(outHInEl.value, 11);
      const tileInches = parseInchesOrDefault(imgInEl.value, 1);
      const gapIn  = Math.max(0, parseInchesOrDefault(gapInEl.value, 0));
      const hexOn  = !!hexToggleEl.checked;
      const circleDiaIn = parseInchesOrDefault(circleDiaInEl.value, 6.25);

      const base = `${originalFileBaseName} Random Pattern`;
      const filename = `${base}.pdf`;

      const { jsPDF } = window.jspdf || {};
      if (!jsPDF) {
        renderInfo.textContent = "PDF export failed: jsPDF not loaded.";
        return;
      }

      // Use points for predictable svg sizing
      const wPt = outWIn * 72;
      const hPt = outHIn * 72;

      const pdf = new jsPDF({
        orientation: (wPt >= hPt) ? "landscape" : "portrait",
        unit: "pt",
        format: [wPt, hPt],
        compress: true
      });

      // VECTOR MODE
      if (vectorToggleEl.checked) {
        try {
          renderInfo.textContent = "Vector mode: tracing image to SVG… (this may take a moment)";
          const tracePPI = clamp(parseNumberOrDefault(tracePPIEl.value, 180), 80, 400);
          const colors = clamp(parseNumberOrDefault(traceColorsEl.value, 8), 2, 32);
          const detail = clamp(parseNumberOrDefault(traceDetailEl.value, 1.0), 0.5, 3.0);

          const svgStr = await traceToSvgString(tracePPI, colors, detail);

          // Create an SVG element for jsPDF.svg()
          const holder = document.createElement("div");
          holder.style.position = "fixed";
          holder.style.left = "-99999px";
          holder.style.top = "-99999px";
          holder.innerHTML = svgStr.trim();
          document.body.appendChild(holder);

          const svgEl = holder.querySelector("svg");
          if (!svgEl) throw new Error("Trace did not produce an SVG element.");

          // Force SVG to scale cleanly to page
          svgEl.setAttribute("width", String(wPt));
          svgEl.setAttribute("height", String(hPt));
          // Ensure viewBox exists; if not, infer from width/height
          if (!svgEl.getAttribute("viewBox")) {
            const vbW = Number(svgEl.getAttribute("width")) || 1000;
            const vbH = Number(svgEl.getAttribute("height")) || 1000;
            svgEl.setAttribute("viewBox", `0 0 ${vbW} ${vbH}`);
          }

          renderInfo.textContent = "Vector mode: embedding SVG into PDF…";

          // pdf.svg returns a Promise
          await pdf.svg(svgEl, { x: 0, y: 0, width: wPt, height: hPt });

          document.body.removeChild(holder);

          // Deliver to iOS (share/open)
          const blob = pdf.output("blob");
          renderInfo.textContent = "Vector PDF built. Opening Share sheet…";
          const shared = await shareBlobIfPossible(blob, filename);
          if (!shared) {
            openBlobInNewTab(blob);
            renderInfo.textContent = "Opened PDF in a new tab. Use Share → Save to Files.";
          } else {
            renderInfo.textContent = "Shared! (Save to Files from the Share sheet.)";
          }
          return;

        } catch (err) {
          console.error(err);
          renderInfo.textContent =
            "Vector export failed (trace or SVG render). Falling back to raster tiled PDF…";
          // continue into raster fallback
        }
      }

      // RASTER FALLBACK (tiled JPEG images in PDF)
      renderInfo.textContent = "Raster PDF: building tiled pages…";

      const rasterPPI = clamp(parseNumberOrDefault(tracePPIEl.value, PDF_RASTER_PPI_DEFAULT), 80, 300);
      const tileIn = PDF_TILE_IN;

      const cols = Math.ceil(outWIn / tileIn);
      const rows = Math.ceil(outHIn / tileIn);

      const tileCanvas = document.createElement("canvas");
      let tctx = tileCanvas.getContext("2d");

      let count = 0;
      const total = cols * rows;

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const x0 = c * tileIn;
          const y0 = r * tileIn;
          const wIn = Math.min(tileIn, outWIn - x0);
          const hIn = Math.min(tileIn, outHIn - y0);

          const wPx = Math.max(1, Math.round(wIn * rasterPPI));
          const hPx = Math.max(1, Math.round(hIn * rasterPPI));

          if (tileCanvas.width !== wPx) tileCanvas.width = wPx;
          if (tileCanvas.height !== hPx) tileCanvas.height = hPx;
          tctx = tileCanvas.getContext("2d");

          renderArtworkTileRaster(tctx, rasterPPI, {
            outWIn, outHIn,
            tileInches, gapIn,
            hexOn, circleDiaIn,
            x0In: x0, y0In: y0, wIn, hIn
          });

          const dataUrl = tileCanvas.toDataURL("image/jpeg", PDF_JPEG_QUALITY);
          // place at correct PT coords
          pdf.addImage(dataUrl, "JPEG", x0 * 72, y0 * 72, wIn * 72, hIn * 72);

          count++;
          if (count % 10 === 0) renderInfo.textContent = `Raster PDF: ${count}/${total} tiles…`;
        }
      }

      const blob = pdf.output("blob");
      renderInfo.textContent = "PDF built. Opening Share sheet…";
      const shared = await shareBlobIfPossible(blob, filename);
      if (!shared) {
        openBlobInNewTab(blob);
        renderInfo.textContent = "Opened PDF in a new tab. Use Share → Save to Files.";
      } else {
        renderInfo.textContent = "Shared! (Save to Files from the Share sheet.)";
      }
    }

    // ---------- pan/zoom preview ----------
    let isPanning = false;
    let panStart = null;

    canvas.addEventListener("pointerdown", (e) => {
      canvas.setPointerCapture(e.pointerId);
      isPanning = true;
      panStart = { x: e.clientX, y: e.clientY, camX: previewCam.xIn, camY: previewCam.yIn };
    });

    canvas.addEventListener("pointermove", (e) => {
      if (!isPanning || !panStart) return;

      const outWIn = parseInchesOrDefault(outWInEl.value, 8.5);
      const outHIn = parseInchesOrDefault(outHInEl.value, 11);

      const rect = canvas.getBoundingClientRect();
      const pxPerInCss = rect.width / PREVIEW_IN;

      const dxInPreview = (e.clientX - panStart.x) / pxPerInCss;
      const dyInPreview = (e.clientY - panStart.y) / pxPerInCss;

      const dxOut = dxInPreview / previewCam.zoom;
      const dyOut = dyInPreview / previewCam.zoom;

      previewCam.xIn = panStart.camX - dxOut;
      previewCam.yIn = panStart.camY - dyOut;

      clampPreviewCam(outWIn, outHIn);
      renderPreview();
    });

    function endPan() { isPanning = false; panStart = null; }
    canvas.addEventListener("pointerup", endPan);
    canvas.addEventListener("pointercancel", endPan);

    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const outWIn = parseInchesOrDefault(outWInEl.value, 8.5);
      const outHIn = parseInchesOrDefault(outHInEl.value, 11);

      const factor = (e.deltaY < 0) ? 1.12 : (1 / 1.12);
      previewCam.zoom = clamp(previewCam.zoom * factor, 1, 8);

      clampPreviewCam(outWIn, outHIn);
      renderPreview();
    }, { passive: false });

    // Mobile pinch zoom
    const activePointers = new Map();
    let pinchStart = null;
    function dist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }

    canvas.addEventListener("pointerdown", (e) => {
      activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
      if (activePointers.size === 2) {
        const pts = Array.from(activePointers.values());
        pinchStart = { d: dist(pts[0], pts[1]), zoom: previewCam.zoom };
      }
    });

    canvas.addEventListener("pointermove", (e) => {
      if (!activePointers.has(e.pointerId)) return;
      activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

      if (activePointers.size === 2 && pinchStart) {
        const outWIn = parseInchesOrDefault(outWInEl.value, 8.5);
        const outHIn = parseInchesOrDefault(outHInEl.value, 11);

        const pts = Array.from(activePointers.values());
        const dNow = dist(pts[0], pts[1]);
        if (pinchStart.d > 0) {
          const ratio = dNow / pinchStart.d;
          previewCam.zoom = clamp(pinchStart.zoom * ratio, 1, 8);
          clampPreviewCam(outWIn, outHIn);
          renderPreview();
        }
      }
    });

    canvas.addEventListener("pointerup", (e) => {
      activePointers.delete(e.pointerId);
      if (activePointers.size < 2) pinchStart = null;
    });
    canvas.addEventListener("pointercancel", (e) => {
      activePointers.delete(e.pointerId);
      if (activePointers.size < 2) pinchStart = null;
    });

    // ---------- buttons ----------
    renderBtn.addEventListener('click', renderPreview);
    exportBtn.addEventListener('click', exportNow);

    // Re-render preview when changing key fields (no auto redraw while typing is fine; this is light)
    [imgInEl, gapInEl, outWInEl, outHInEl, circleDiaInEl, traceDetailEl, traceColorsEl, tracePPIEl].forEach(el => {
      el.addEventListener("change", renderPreview);
    });
    [hexToggleEl, vectorToggleEl].forEach(el => el.addEventListener("change", renderPreview));

    // Initial draw
    renderPreview();
  </script>
</body>
</html>
